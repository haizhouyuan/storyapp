跳至内容
历史聊天记录

您说：
2025-09-01-master-ultrathin.txt
文档
这是claudecode给我的服务器部署多个服务的方案，你有没有更好的建议
ChatGPT 说：
Request for GPT-5 Pro
Reasoned for 6m 42s
结论先说在前面：用“不同外部端口”同时跑多个版本可行，但不是长期最优。更稳妥、可维护、可灰度/回滚更顺滑的做法是把对外端口统一到 80/443，通过反向代理（强烈建议 Traefik 或 Nginx）按「子域名/路径/头部」路由到不同版本；同时把进程与资源隔离到容器或至少到独立的进程组。下面给出三套从轻到重的落地方案和完整操作清单，你可以直接拷贝执行。

你现有“多端口并行”的问题点
安全暴露面大：大量非常规端口（8080、5001…）对外开放，不利于安全组与合规审计。

体验与治理复杂：前端/后端 URL、CSP、跨域、探活地址都要随端口变化，文档与排障成本上升。

灰度与回滚不顺：仅靠端口切换很难做按百分比流量分配、按用户定向灰度、快速一键回滚。

推荐方案 A（强烈推荐）：Docker Compose + Traefik + 子域名（对外只开 80/443）
特点：

外部只暴露 80/443；通过子域名或路径把流量路由到具体版本（blue/green）。

内部端口随便用（5000/5001/…），对外不可见。

自带自动 HTTPS（Let’s Encrypt），切换版本只需改 Label 或环境变量并 docker compose up -d 即可。

支持“定向灰度”（例如带特定 Header 的请求命中新版本）。

域名与端口规划
app.example.com → 前端当前“生产版”

api.example.com → 后端当前“生产版”

canary.example.com 或加 Header X-Canary: 1 → 命中新版本（绿版本）

内部容器端口：blue(5000)、green(5001)，MongoDB 27017（仅内网网络）

目录与文件
/opt/svp/
├─ backend/                 # 你的后端工程
├─ frontend/                # 你的前端工程
├─ ops/
│   ├─ traefik/             # Traefik 持久化目录
│   │   └─ acme.json
│   └─ mongo/               # MongoDB 数据卷
│       └─ data/
└─ docker-compose.yml
ops/traefik/acme.json 首次 touch 后 chmod 600。

核心 docker-compose.yml（示例，可直接用）
version: "3.9"

networks:
  web:
  internal:

volumes:
  mongo_data:

services:
  traefik:
    image: traefik:v3.1
    command:
      - --providers.docker=true
      - --providers.docker.exposedbydefault=false
      - --entrypoints.web.address=:80
      - --entrypoints.websecure.address=:443
      - --certificatesresolvers.le.acme.email=ops@example.com
      - --certificatesresolvers.le.acme.storage=/letsencrypt/acme.json
      - --certificatesresolvers.le.acme.httpchallenge=true
      - --certificatesresolvers.le.acme.httpchallenge.entrypoint=web
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ./ops/traefik/acme.json:/letsencrypt/acme.json
    networks: [web]

  mongo:
    image: mongo:7
    command: ["--bind_ip_all"]
    volumes:
      - mongo_data:/data/db
    networks: [internal]

  backend-blue:
    build: ./backend
    environment:
      - PORT=5000
      - NODE_ENV=production
      - MONGODB_URI=mongodb://mongo:27017/svp_prod
    networks: [web, internal]
    labels:
      - traefik.enable=true
      # 生产后端入口（蓝）
      - traefik.http.routers.api.rule=Host(`api.example.com`)
      - traefik.http.routers.api.entrypoints=websecure
      - traefik.http.routers.api.tls.certresolver=le
      - traefik.http.services.api.loadbalancer.server.port=5000

  backend-green:
    build: ./backend
    environment:
      - PORT=5001
      - NODE_ENV=staging
      - MONGODB_URI=mongodb://mongo:27017/svp_staging
    networks: [web, internal]
    labels:
      - traefik.enable=true
      # 定向灰度入口（仅携带 Header 的请求命中绿）
      - traefik.http.routers.api-canary.rule=Host(`api.example.com`) && Headers(`X-Canary`,`1`)
      - traefik.http.routers.api-canary.entrypoints=websecure
      - traefik.http.routers.api-canary.tls.certresolver=le
      - traefik.http.services.api-canary.loadbalancer.server.port=5001

  # 前端建议用 Nginx 容器承载静态文件
  web-prod:
    image: nginx:alpine
    volumes:
      - ./frontend/build:/usr/share/nginx/html:ro
    networks: [web]
    labels:
      - traefik.enable=true
      - traefik.http.routers.web.rule=Host(`app.example.com`)
      - traefik.http.routers.web.entrypoints=websecure
      - traefik.http.routers.web.tls.certresolver=le
      - traefik.http.services.web.loadbalancer.server.port=80
切换与灰度
小流量定向灰度：测试用户在调用 API 时加 Header X-Canary: 1，即走绿版。

一键“蓝→绿”切换：把 api 路由的 service 改绑定到 backend-green（变更 label），执行：

docker compose up -d
切回也同理，几秒内完成，无需改外网端口、无缝回滚。

资源与安全
安全组仅放行 80/443 和 22（SSH），其余端口仅容器内部可见。

docker compose 配合 --memory、--cpus 给后台服务限额，防止测试版抢占资源。

MongoDB 用不同库名：svp_prod、svp_staging，或再起一个独立 Mongo 容器也可。

证书自动续期由 Traefik 处理，无需手工管理。

推荐方案 B（轻量、不上容器）：Nginx 反代 + PM2 蓝绿 + 定向灰度
如果暂不引入 Docker，可以延续 PM2，但把“对外端口”统一到 80/443，由 Nginx 做路由与灰度。

PM2 多实例
ecosystem.config.js 增加两个进程：

module.exports = {
  apps: [
    { name: "svp-backend-blue",  script: "dist/server.js", env: { PORT: 5000, NODE_ENV: "production", MONGODB_URI: "mongodb://127.0.0.1:27017/svp_prod" } },
    { name: "svp-backend-green", script: "dist/server.js", env: { PORT: 5001, NODE_ENV: "staging",   MONGODB_URI: "mongodb://127.0.0.1:27017/svp_staging" } }
  ]
}
启动：

pm2 start ecosystem.config.js
pm2 save
Nginx（对外仍是 80/443）
示例，仅显示核心逻辑（HTTPS 与静态资源略）：

# 生产蓝/绿上游
upstream api_blue  { server 127.0.0.1:5000 weight=9 max_fails=3 fail_timeout=5s; }
upstream api_green { server 127.0.0.1:5001 weight=1 max_fails=3 fail_timeout=5s; }

# header 定向灰度：携带 X-Canary:1 → 绿，其余走蓝
map $http_x_canary $api_upstream {
    default       http://api_blue;
    "1"           http://api_green;
}

server {
    listen 80;
    server_name api.example.com;

    location / {
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $remote_addr;
        proxy_pass $api_upstream;
    }
}
想做“10% 自动灰度”，可用 split_clients：

split_clients "${remote_addr}${http_user_agent}" $canary {
    10% "green";
    *   "blue";
}
map $canary $api_upstream {
    "green"  http://api_green;
    default  http://api_blue;
}
回滚/切换：把 weight 或 map 的目标指向另一侧，nginx -s reload 即可。

外部仍只有 80/443，安全与体验一致。

推荐方案 C（中长期可扩展）：单机 K3s/Kubernetes + Traefik Ingress
单台 ECS 即可安装 K3s，默认自带 Traefik Ingress。

用 Deployment/Service/Ingress 做版本编排、弹性伸缩、金丝雀/蓝绿（配合 Argo Rollouts 更优雅）。

适合你后续要做多团队协作、更多服务、自动化交付的中长期演进。

配套“标配”清单（不管选 A/B/C 都建议）
统一探活：/health（liveness）与 /ready（readiness），放开代理直通。

统一日志：JSON 行日志；按环境写入不同路径或容器标签，便于聚合检索（后续可接阿里云日志服务/ELK/Vector）。

统一备份：Mongo 每日 mongodump，保留 7/14 天，打包上 OSS；恢复演练月度一次。

统一发布：GitHub Actions（或自建 Runner）→ SSH 到服务器执行 docker compose pull && up -d 或 pm2 reload，发布全自动。

统一限额：容器 --memory/--cpus 或 PM2 --max-memory-restart=512M，防止测试任务拖垮生产。

统一安全：仅 22/80/443 入站，Fail2ban、自动证书、HSTS、后端仅内网可达。

如果你坚持“多端口并行”的思路（短期权宜）
也建议只在内网用多端口，对外仍通过 Nginx 把多端口“收敛”为 80/443；

前端以子域名区分版本（app.example.com、app-canary.example.com），不要让用户记端口；

安全组关闭对外 8080/5001 等端口，避免被扫；

PM2 用独立进程名/日志路径，Mongo 用不同库名，定时清理历史数据。

一键落地步骤（以方案 A 为例）
准备目录与权限

sudo mkdir -p /opt/svp/ops/traefik /opt/svp/ops/mongo
sudo touch /opt/svp/ops/traefik/acme.json && sudo chmod 600 /opt/svp/ops/traefik/acme.json
写入上面的 docker-compose.yml 并修改 example.com 为你的域名；A 记录指向 ECS。

启动

cd /opt/svp
docker compose up -d --build
验证

https://app.example.com 前端可访问

https://api.example.com/health 返回 200（蓝）

带 Header X-Canary: 1 访问 https://api.example.com/health 命中绿

切换生产到绿

调整 Traefik Label（把 routers.api 的 service 指到绿）并 docker compose up -d

若异常，复位 label 回蓝，秒级回滚

什么时候选哪套？
需要最快落地、最少改造：方案 B

需要 HTTPS 自动化、统一入口、安全可控、灰度/回滚顺滑：方案 A

预计服务数上升、需要更强的编排与弹性：方案 C

如果你把当前的“多端口方案”当作过渡，我建议尽快切到方案 A：治理成本最低、上线与回滚最稳妥，对团队协作也最友好。需要的话，我可以帮你把你现有的 Nginx/PM2 配置、环境变量和域名清单映射成可直接运行的 Compose 清单与切换脚本。

您说：
2025-09-01-master-ultrathin.txt
文档
这是claudecode给我的服务器部署多个服务的方案，你有没有更好的建议
ChatGPT 说：
我看到了ClaudeCode给出的多端口部署方案，并了解了你的整体部署结构。你希望我基于这个方案给出更好的建议。请问你更关注哪方面的优化？

更便捷的版本切换（比如蓝绿、灰度发布）

更安全的端口/服务隔离策略

更自动化的运维流程（比如一键部署/回滚）

更适合 CI/CD 的多环境发布模式

更清晰的目录和资源管理

另外：

你希望方案保留“非容器化部署”还是可以考虑引入 Docker？

你目前的服务器是单台 ECS 还是多实例？

请补充一下你最关心的目标，我再给出针对性的优化建议。

您说：
12345都关注，docker和非docker都给出方案，单实例
ChatGPT 说：
明白了。我将为你整理一套完整的部署优化方案，涵盖多端口部署、Docker与非Docker两种形态，适配单台实例，并着重解决你关注的以下目标：

版本切换便捷（蓝绿/灰度）

安全隔离（服务/端口/数据）

自动化运维（部署/回滚脚本）

多环境发布（prod/dev/test）

清晰的目录与资源管理

我会综合架构、部署工具（如PM2、Nginx、Traefik）、环境变量隔离、CI/CD集成、日志与数据库分离等方面给出落地方案。

稍等片刻，我整理完就告诉你。

Research completed in 8m· 14 个源· 118 个搜索
单机多版本部署优化方案（含Docker与非Docker）

单实例多版本部署优化方案（Docker 与非 Docker）
本文针对在单台阿里云 ECS 实例上部署 React 前端 + Node.js 后端 + MongoDB 的项目，提出非 Docker与基于 Docker两种多版本共存部署方案，并满足以下目标：
**多版本共存隔离：**生产和测试版本同时运行且互不影响（通过不同端口或域名区分）。
**版本平滑切换：**支持蓝绿部署和灰度发布，实现新旧版本的无缝切换及部分流量逐步导入。
**安全隔离措施：**通过端口限制、数据库区分、日志分离等手段保证不同版本之间的安全隔离。
**自动化部署回滚：**提供一键部署和回滚脚本，清晰定义部署流程，降低人为操作失误。
**清晰的结构管理：**规划明确的目录结构和资源管理策略（配置、日志、数据库等分离管理）。
下文分别介绍非 Docker 方案和Docker 方案的架构、实现细节，并进行优劣对比，供参考实施。
方案一：非 Docker 的多版本部署
架构概览
非 Docker 环境下，我们采用 Nginx + PM2 + 单实例 MongoDB 的架构，实现生产版与测试版两套环境在同一服务器共存运行。Nginx作为前端反向代理，通过不同域名或路径将流量转发到对应的 Node.js 实例（生产或测试）。每套环境的Node.js后端使用PM2守护进程管理，并连接到各自独立的MongoDB数据库（在同一MongoDB实例中通过不同数据库名区分）。React前端将打包后的静态文件分别部署在不同目录，由Nginx区分域名提供静态服务或通过Node.js提供静态文件。 示例架构：Nginx 根据不同子域名将请求分别代理到两套 Node.js 服务（监听不同端口），实现单服务器上的多版本部署
server.51cto.com
server.51cto.com
。两套服务共用同一个 MongoDB 实例，但使用独立的数据库名称。 在该架构中：
**Nginx：**监听服务器80端口（以及443端口用于HTTPS），根据请求的域名或URL路径，将流量反向代理到相应的后端服务。生产环境和测试环境使用不同的域名（或二级域名）来区分，例如 www.example.com 指向生产版，test.example.com 指向测试版。
server.51cto.com
server.51cto.com
这样利用Nginx的转发机制，实现多个Web服务共享80/443端口，而后端服务本身无需占用公共端口。
**Node.js 应用（后端）：**生产版和测试版各自运行一套独立的 Node.js 应用进程，监听不同的内部端口（例如生产版监听 localhost:3000，测试版监听 localhost:3001）。通过 PM2 管理进程启停和自动重启。两套应用的代码可以来自同一代码库的不同分支或 Tag，也可以在文件系统上放置于不同目录。每套应用通过配置使用不同的环境变量，以连接各自的数据库、使用各自的日志路径等。
**React 前端：**前端采用 React 构建，最终产出静态资源文件。一种做法是将生产和测试两套前端构建结果分别存放到服务器不同目录，由Nginx配置不同的 root 路径服务静态文件。例如，Nginx 为生产域名配置根目录指向 /var/www/myapp/prod/frontend/，为测试域名配置根目录指向 /var/www/myapp/test/frontend/，从而各自加载对应版本的前端静态页面。另一种做法是由 Node.js 后端提供静态文件服务，这种情况下每套 Node.js 应用内部会托管其对应的前端静态资源。
**MongoDB 数据库：**继续使用单节点的 MongoDB 服务，但在逻辑上为不同版本的应用使用不同的数据库（Database）。例如，生产版使用数据库 myapp_prod，测试版使用数据库 myapp_test。通过这种“库分离”，保证测试数据和生产数据完全隔离，互不影响。必要时也可以为测试环境启用单独的 MongoDB 实例或副本（例如运行在不同端口），但通常在单机情况下，使用同一Mongo实例的不同数据库即可满足隔离要求，同时降低资源开销。
**工作流程概述：**Nginx接受来自客户端的请求，并根据域名将请求代理到对应版本的Node.js后端。Node.js后端处理业务逻辑，访问其配置的MongoDB数据库（生产或测试库），并返回响应。React前端在浏览器中通过域名访问时，会由Nginx提供正确版本的静态文件，并调用对应域名下的API（已由Nginx代理到相应后端服务）。整个流程中，生产与测试两套环境从前端、后端到数据库均严格隔离，只共享底层操作系统和硬件资源。这样即使在同一服务器上，也能保证测试版本的变更不会影响线上生产用户。
端口与域名规划
域名规划：建议采用不同域名或二级域名来区分生产与测试环境，以方便通过Nginx进行流量分发，同时对外仍使用标准的80/443端口。比如：
生产环境域名：www.example.com（或正式域名）
测试环境域名：test.example.com（或某个内部测试域名）
将以上两个域名的DNS记录都解析到同一台ECS实例的IP地址。
server.51cto.com
Nginx根据Host头来区分请求属于哪个域名，从而路由到不同的后端服务。这种方式避免了直接在URL中暴露非常规端口，用户访问两个环境时都使用熟悉的80/443端口，在URL层面也能清晰地区分环境。 **端口规划：**在服务器内部，不同版本的Node.js应用监听不同的端口号。例如：
生产版 Node.js 后端监听 3000 端口 (仅本地访问)
测试版 Node.js 后端监听 3001 端口 (仅本地访问)
这些端口号只在服务器内部使用，Nginx 将外部的HTTP/HTTPS请求分别代理到 localhost:3000 或 localhost:3001。
server.51cto.com
Node.js应用本身不要占用80或443端口，以免冲突。通过这种端口规划，可以在一台服务器上同时运行多套服务。Nginx配置示例（概念上）：
# 生产环境 Nginx 配置段落
server {
    listen       80;
    server_name  www.example.com;
    root /var/www/myapp/prod/frontend/;  # 前端静态文件路径（如果用Nginx服务静态文件）
    location /api/ {
        proxy_pass http://localhost:3000;  # 转发API请求到生产Node服务
    }
}

# 测试环境 Nginx 配置段落
server {
    listen       80;
    server_name  test.example.com;
    root /var/www/myapp/test/frontend/;   # 静态文件路径
    location /api/ {
        proxy_pass http://localhost:3001;  # 转发API请求到测试Node服务
    }
}
注意：上述只是示意配置。实际可根据项目情况调整，例如若Node.js直接提供前端页面，则Nginx可将所有请求都代理给对应端口的Node服务，而无需配置静态root。关键是利用不同域名，同端口的方式实现路由分发，从而保证对外接口始终是标准80/443端口
server.51cto.com
。
**DNS与防火墙设置：**在域名解析完成后，还需确保ECS安全组和防火墙仅对外开放80和443端口。测试版后端使用的3001等内部端口不对公网开放（Node进程监听可以绑在127.0.0.1或使用防火墙规则限制），确保外部只能通过域名访问，不能绕过Nginx直接访问内部端口。这是基本的安全要求。
部署目录结构
为方便管理不同版本的代码、配置和数据，我们按照环境版本划分清晰的目录结构。建议在服务器上建立一个顶层部署目录（如 /deploy/myapp/ 或 /var/www/myapp/），其下分子目录存放生产和测试两个版本的资源。例如：
/var/www/myapp/
├── prod/                    # 生产环境相关文件
│   ├── backend/             # Node.js 后端代码（生产版）
│   ├── frontend/            # React前端构建输出（生产版静态文件）
│   ├── config/              # 配置文件（生产环境，如 .env.prod）
│   ├── logs/                # 日志目录（生产环境）
│   └── node_modules/        # 依赖（生产版，如采用独立安装依赖）
├── test/                    # 测试环境相关文件
│   ├── backend/             # Node.js 后端代码（测试版）
│   ├── frontend/            # React前端构建输出（测试版静态文件）
│   ├── config/              # 配置文件（测试环境，如 .env.test）
│   ├── logs/                # 日志目录（测试环境）
│   └── node_modules/        # 依赖（测试版）
└── shared/                  # （可选）共享资源，如脚本、公共配置等
说明：
将生产和测试版本的代码分别放入 prod/backend 和 test/backend（两者可以通过 Git 不同分支/Tag 部署得到）。这样可以同时保留两套代码，各自独立运行。React前端的构建产物分别存放在 prod/frontend 和 test/frontend，对应各自版本的静态文件。
config 目录用于放置配置文件或环境变量文件。例如可以有 prod/config/.env（生产版环境变量）和 test/config/.env（测试版环境变量），其中配置不同的数据库连接字符串、日志路径、第三方API密钥等。应用启动时由PM2或启动脚本加载相应环境的配置。
logs 目录分别用于存储不同环境的日志。例如生产版的应用日志、错误日志输出到 prod/logs/ 下，测试版输出到 test/logs/ 下。Nginx也可针对不同域名配置不同的 access log 路径，实现日志的隔离。
node_modules 是否分别维护取决于部署方式。如果采用独立的部署目录，通常各自安装依赖库，以避免版本冲突。如果要节省空间，也可以考虑让两套环境共用一些依赖，但一般为了环境独立性，还是分开更安全。
shared 目录可选，用于放置一些公共脚本或配置模板。如果没有需要也可以不设。
版本区分方式：如上所述，推荐使用文件路径区分不同版本。通过Git拉取不同分支到不同目录即可实现。例如拉取 master 分支代码到 prod/backend 作为生产版，拉取 develop 分支代码到 test/backend 作为测试版。也可以采用Git Tag或Release归档特定版本部署到相应目录。这样文件层面就清晰地隔离了版本。同时配合不同的Nginx站点根目录、不同的PM2进程名、不同的配置文件，构成两套并行的运行环境。 静态资源管理：对于React前端构建出的静态文件，一种管理方式是在每次部署时将 build 出来的文件拷贝到对应的 frontend 目录中，并清理过期的旧版本文件（如果有版本快照需求也可按版本号存多个子目录）。由于Nginx配置了不同的root，能够各自读取正确版本的文件。务必确保生产和测试的静态资源文件名或路径不会冲突（通常React构建产物都有哈希文件名，不会冲突）。此外，可以将前端与后端一起置于 backend 中（例如把前端build后文件放在Node应用的 public/ 下），视项目情况选择。核心目标是目录清晰，版本独立。
部署流程与脚本模板
部署流程：在非Docker方案下，部署通常通过拉取代码、安装依赖、构建前端、启动进程等步骤完成。以下是一套典型的生产/测试环境并存部署流程：
**获取最新代码：**在目标环境目录下执行Git拉取或解压发布包。比如在 test/backend/ 下运行 git pull origin develop 获取最新测试版代码（生产环境则pull主干或Tag）。
**安装依赖：**进入后端目录，运行 npm install（或yarn）安装所需依赖库。如果前后端分离仓库，可能还需分别安装前端依赖并构建。
**前端构建：**在前端源码目录运行构建命令（如 npm run build），将生成的静态文件输出到预定的 frontend/ 目录。确保Nginx能够访问这些文件。
**配置调整：**更新该环境的配置文件（如 .env）确保其中的参数正确无误（尤其是数据库连接、第三方服务的测试/生产凭据等）。
**启动/重启服务：**使用 PM2 启动或重启 Node.js 应用进程。可以使用不同的进程名区分环境，例如生产版命名为 myapp-prod，测试版为 myapp-test。假设在代码中监听端口通过环境变量控制，则启动命令示例：
# 启动或重启测试环境应用
pm2 start npm --name "myapp-test" --cwd /var/www/myapp/test/backend/ -- run start  
（其中 --cwd 指定工作目录，npm run start 脚本内应读取.env.test设置的PORT=3001等配置。）对于生产环境类似：
pm2 start npm --name "myapp-prod" --cwd /var/www/myapp/prod/backend/ -- run start  
使用PM2可以确保应用以守护进程方式运行，并且在服务器重启后自动拉起（可通过 pm2 save 和配置自启动实现）。
**验证测试环境：**首先在测试版环境完成部署后，通过内网地址或临时域名访问测试版进行验证。确认功能正常、日志无误、与测试数据库的交互正确等。因为测试版不会暴露给公众用户，可以在部署后由测试人员先行验证。
**更新生产环境：**在需要发布新版本时，按照类似流程在 prod 目录执行代码更新、构建和重启。但生产环境发布需谨慎，可以先将新版本部署到备用环境进行蓝绿切换（详见下节）。
自动化脚本：为了提高部署效率和可靠性，可以编写一键部署的Shell脚本。以下提供一个简化的部署脚本模板（针对蓝绿发布场景），用于将新版本部署到“闲置”环境并切换流量：
#!/bin/bash
# 假设当前生产运行在端口3000 (blue)，备用为3001 (green)
PROD_PORT=3000
STAGE_PORT=3001
NGINX_CONF="/etc/nginx/conf.d/myapp.conf"   # Nginx配置文件路径

# 确定当前活跃环境
CURRENT_PORT=$(grep -oP 'proxy_pass http://localhost:\K\d+' $NGINX_CONF)
if [ "$CURRENT_PORT" == "$PROD_PORT" ]; then
    TARGET_PORT=$STAGE_PORT      # 当前prod在3000，则准备在3001部署新版本
    TARGET_DIR="/var/www/myapp/green"   # green环境目录（假设prod对应blue目录，备用为green目录）
    OLD_NAME="myapp-blue"
    NEW_NAME="myapp-green"
else
    TARGET_PORT=$PROD_PORT
    TARGET_DIR="/var/www/myapp/blue"
    OLD_NAME="myapp-green"
    NEW_NAME="myapp-blue"
fi

echo "部署新版本到环境目录: $TARGET_DIR (端口:$TARGET_PORT)..."
cd $TARGET_DIR/backend
git pull origin master              # 拉取最新代码（生产以master为例）
npm install --production            # 安装依赖
npm run build                       # 构建前端（若后端服务静态文件）或在frontend目录构建
# 启动新版本应用
pm2 start npm --name "$NEW_NAME" --cwd $TARGET_DIR/backend -- run start -- --port $TARGET_PORT
sleep 5  # 等待应用启动

# 健康检查
STATUS=$(curl -o /dev/null -s -w "%{http_code}" http://localhost:$TARGET_PORT/health)
if [ "$STATUS" != "200" ]; then
  echo "新版本健康检查未通过，状态码: $STATUS"
  pm2 delete $NEW_NAME
  exit 1
fi

# 切换Nginx流量
sed -i "s/proxy_pass http:\/\/localhost:$CURRENT_PORT;/proxy_pass http:\/\/localhost:$TARGET_PORT;/" $NGINX_CONF
nginx -s reload
echo "Nginx 已切换流量至端口 $TARGET_PORT ($NEW_NAME)."

# 停止旧版本
pm2 stop $OLD_NAME && pm2 delete $OLD_NAME
pm2 save
echo "旧版本进程 $OLD_NAME 已停止，新版本 $NEW_NAME 正在提供服务。"
上述脚本执行了代码更新、依赖安装、应用启动、健康检查，修改Nginx配置完成蓝绿切换并清理旧进程等步骤
medium.com
medium.com
。实际使用中可根据项目名称、路径进行调整，并加入错误处理和通知。执行该脚本即可一键部署并切换到新版本，做到最小化停机和自动回滚（若健康检查失败则不切换）。另外也可以准备回滚脚本，在发现新版本故障时快速恢复旧版本（原理是将Nginx代理改回旧端口并重启旧进程，如果旧版本进程还在则直接切流量即可实现秒级回退）。 通过以上流程和脚本模板，实现了清晰的手工或自动化部署步骤。团队成员可以将这些步骤编写成部署手册，在每次发布时遵循，确保一致性。也可以结合 Git Hooks、CI/CD 工具（如 Jenkins、GitHub Actions）来触发脚本，实现代码合并后自动部署到测试或生产，提高效率
medium.com
medium.com
。
版本切换方式（蓝绿部署 / 灰度发布）
1. 蓝绿部署： 蓝绿部署（Blue-Green Deployment）是实现零停机发布的一种重要策略。核心思想是维护两套生产环境：一套为当前线上活跃版本（称为 Blue），另一套为空闲的备用版本（称为 Green）。当我们需要发布新版本时，先将新版本部署到备用环境（Green）上，使其与现有版本 (Blue) 并行运行。新版本部署完成并经过测试验证后，通过切换流量使 Green 环境成为新的活跃环境，而原来的 Blue 环境停止接收流量。
medium.com
infoq.cn
 在单服务器场景，我们同样可以应用蓝绿部署思想：始终保留两套应用实例（例如运行在不同端口的两份 Node.js 服务），每次发布时不替换正在运行的版本，而是将更新部署到另一个闲置实例，再通过调整Nginx代理将用户请求切换过去。具体实现要点：
**双环境配置：**如前文所述，可将生产和测试环境用于蓝绿角色，或者额外定义 Blue/Green 两套目录和配置。例如上面的脚本中我们将 /prod 视为 Blue，/green 视为 Green，两者端口不同，各自运行一份应用。
**切换流量：**通过修改 Nginx 配置中的上游转发地址来实现。例如最初 Nginx 的 proxy_pass 指向 localhost:3000 (Blue)，当Green环境（3001端口）部署完成测试OK后，将配置改为指向 localhost:3001 并平滑重载Nginx，使所有新请求都转到Green版本
medium.com
。由于两个版本同时在线，切换瞬间不会中断服务，实现零停机升级。
**快速回滚：**在蓝绿发布中，如果新版本（Green）发生严重问题，可以立即将Nginx代理切回原来的Blue环境（原进程还在运行），所有流量“秒级”回归旧版本
infoq.cn
infoq.cn
。然后再下线处理Green环境。这种快速回退能力将发布风险降到最低。
**验证与上线：**在切换正式用户流量之前，新版本Green可以在后台先跑一段时间，用少量内部流量或监控来验证性能。如有条件，也可以在切换前让一部分测试用户通过测试域名试用Green版本（但严格来说那更接近灰度发布范畴）。当确认无误后，再正式执行切流量。
蓝绿部署的特点是：同时维护两套完整环境，切换时流量在新旧之间完全倒换
blog.csdn.net
。这保证了发布过程的稳定和可控。当然在单机上，由于资源有限，Blue/Green通常不会是两套大规模集群，而只是两个进程实例，但原理一样适用。需要注意的是，在单机蓝绿切换时，注意避免两个版本争用相同的资源。例如确保它们使用不同端口、不同日志文件、不同数据库，以免交叉影响。
蓝绿部署示意：“蓝色”版本与“绿色”版本两套应用在发布过程中同时在线。先将绿色版本部署好并测试，然后将所有用户请求由蓝版本切换到绿版本。老的蓝版本暂时保留运行，以便出现问题时快速回切
infoq.cn
。如果一段时间后绿版本稳定运行，再停止蓝版本。这一过程对用户是无感知的，不会中断服务。
2. 灰度发布： 灰度发布（也称金丝雀发布，Canary Release）是一种渐进式的发布策略，即在黑与白之间逐步过渡，让新旧版本同时服务一部分用户
blog.csdn.net
。具体来说，灰度发布不会像蓝绿那样一次性将所有用户切换到新版本，而是让一小部分用户先体验新版本B，而大部分用户仍然使用旧版本A。如果新版本表现良好，再逐步扩大新版本用户范围，直到全部迁移到B版本
blog.csdn.net
。灰度发布可以通过多种手段实现流量按比例或按规则分配：
按比例切流：例如先让5%的流量进入新版本，其余95%仍用旧版本；观察一段时间无异常，再提高到30%、50%，最终100%。这种逐步提升比例的方法是典型的灰度策略
amazonaws.cn
infoq.cn
。在Nginx层面，可以通过配置上游的权重来实现。例如将上游配置两个服务器：旧版本权重90，新版本权重10，大致达到10%流量新版本的目的（注意Nginx开源版的加权负载均衡不能严格精确百分比，但在流量大时近似）。也可以使用Nginx的 split_clients 模块按照随机数划分流量百分比。
按用户分组：选择特定用户群体进入新版本。例如可以根据用户ID、地理区域、IP段等做路由。比如只让内部测试账号或某些测试用户访问新版本（通过给这些用户下发特殊cookie或使用特定二级域名指向新版本服务）。Nginx可以借助 map、Lua脚本或借助服务网关实现按cookie/头部路由部分流量
blog.csdn.net
infoq.cn
。这样，新老版本并行一段时间，新版本只影响特定用户群。
**按时间窗口滚动：**某些情况下也会逐批发布，例如第1天放出给10%用户，第2天扩大到50%，第3天全量。这在小规模部署上通常通过人工调整上述规则实现，没有严格时间自动化，但原则类似。
在单台服务器上实现灰度发布需要精心设置Nginx或应用网关的路由策略。相对来说，灰度发布更常见于有负载均衡的多实例部署，通过逐台替换实例或流量调度实现。如果只有单实例，灰度发布可以借助并行的测试环境来实现某种程度的金丝雀测试：例如让内部人员使用测试域名（指向新版本）体验，即相当于少数“用户”用了新版本，而普通用户还在用旧版本。这虽然不是真正按比例随机的灰度，但也起到了渐进验证的效果。
灰度发布定义引用：“灰度发布是一种平滑过渡的发布方式，即让一部分用户继续用旧版本A，一部分用户开始用新版本B。如果用户对B没有明显问题，再逐步扩大B的范围，最终全部切换为B版本
blog.csdn.net
。”这种方式可以在不影响整体系统稳定的前提下，尽早发现新版本潜在问题，并降低发布风险
blog.csdn.net
blog.csdn.net
。
结合蓝绿与灰度：在实践中，蓝绿部署和灰度发布并不冲突，甚至可以配合使用。例如先通过蓝绿方式部署新版本到并行环境，然后利用灰度策略引流一部分用户到Green环境做验证
infoq.cn
infoq.cn
。如果一切正常，再执行全量切换。这在需要谨慎发布的重要系统中非常有效。不过在单服务器场景，由于没有额外的负载均衡组件，通常灰度控制手段有限，可以考虑在应用内部做一些灰度逻辑（例如代码里检查用户是否在测试名单），或通过Nginx简单权重实现。对于题目要求，我们提供灰度发布概念支持，但实现重点仍在蓝绿切换，因为单实例的灰度发布可控度相对有限。
安全隔离措施
在同一台服务器运行多套环境时，必须采取适当的安全隔离措施，以防止测试环境对生产环境造成影响，并保护生产数据安全。 **1. 端口访问控制：**除必要的80/443端口对外开放外，其它服务端口应严格受控。具体包括：
后端 Node.js 服务的端口（如3000,3001）只在本地监听 127.0.0.1，不绑定公网IP。这可通过应用代码或PM2配置来确保。即使监听在0.0.0.0，也要通过防火墙或安全组禁止外网访问这些高位端口。这样，外部流量只能通过Nginx访问应用，有效防止绕过代理的非法访问。
MongoDB 默认监听27017端口，也建议防火墙只允许本机访问，或在MongoDB配置中将绑定IP设为localhost（除非有远程连接需求，但生产DB通常不开放公网）。如果测试需要远程连接MongoDB，也应为测试库设置单独账户授权，并通过SSH隧道等安全方式连接，而不直接开放数据库端口。
2. 数据库隔离：如前所述，生产和测试使用不同的数据库名称，实现数据层的逻辑隔离。例如生产库名为myapp_prod，测试库名为myapp_test。应用在连接MongoDB时通过不同的连接字符串或凭据访问各自库。同时可以为两套环境创建不同的数据库用户，赋权只访问对应库。这样，即使测试环境的代码出问题，也不会误读/写生产数据。若需要更彻底，可运行两套MongoDB服务：如在测试环境启动一个MongoDB实例绑定localhost:27018端口，使用独立的数据存储路径。这将物理隔离数据，但代价是资源翻倍占用。在单机资源有限时，通常采用一实例多库方式足矣。关键是做好权限和备份：定期备份生产库，测试库的数据视需要决定是否保留快照等。测试环境绝不能直接连到生产库。 **3. 文件与日志隔离：**确保不同环境的文件读写互不干扰：
**日志隔离：**配置应用将日志输出到各自环境的日志目录。例如PM2可通过配置文件指定不同的 out_file 和 error_file 路径。Nginx也可在每个server块内指定不同的access log和error log文件，用域名区分。这样分析日志时不会混淆。同时定期对测试日志和生产日志分别归档、清理。
**配置隔离：**敏感配置如密钥、OAuth凭证等，可在生产和测试使用不同的值，并分别存放（如 .env.prod vs .env.test）。不要在测试环境使用生产的密钥，以免泄露风险。可以通过环境变量或配置文件管理，使得测试应用和生产应用启动时各自只加载自己的配置。
**文件存储隔离：**如果应用有上传文件或生成报表文件等IO操作，也应区分路径。例如文件上传目录设置为 /var/www/myapp/prod/uploads 和 /var/www/myapp/test/uploads 分开，避免测试操作覆盖生产文件。对于静态资源（如果用户可上传），也要考虑隔离或者采用不同的CDN路径。
**4. 访问限制：**视情况对测试环境加额外限制，例如：
**HTTP认证或IP白名单：**如果不希望测试环境被随意访问，可在Nginx为 test.example.com 配置简单的HTTP Basic Auth，只有知道密码的人才能访问测试站点。或者限制仅公司内部IP可以访问测试域名。这防止测试环境暴露给未授权用户。
**robots屏蔽：**在测试环境的站点上添加robots.txt禁止搜索引擎索引，避免测试站点被搜索引擎收录造成信息泄露或SEO困扰。
**5. 进程隔离：**由于两套Node应用运行在同一系统上，可以考虑通过不同的Linux用户来运行，以限制权限。例如生产应用由用户produser运行，只能写prod/目录；测试应用由用户testuser运行，只能写test/目录。这样即使某一环境被入侵，权限也受限，不至于篡改另一环境的文件。设置文件夹权限配合用户组，实现简单的权限分离。不过在单机上，这种进程级隔离有限，并增加运维复杂性，一般在需要更高安全时采用。如果使用Docker方案则容器本身也提供了隔离（见后述Docker安全部分）。 **6. SSL证书：**为生产和测试域名分别配置SSL证书（如果有正式域名和测试域名）。免费证书服务（如Let’s Encrypt）可以为test.example.com也签发证书。这样不论访问哪个环境，都是HTTPS加密的，防止中间人攻击窃听测试环境流量（测试环境可能用真实数据做测试）。同时证书也可以防止用户误信任假冒测试站点。生产证书和测试证书的私钥都要妥善保管。 通过以上措施，多版本环境在同一服务器上依然可以做到尽可能接近独立的安全环境。测试环境的问题不会蔓延到生产，生产数据也不会因测试被破坏，从而满足企业对于测试与生产隔离的安全合规要求。
优点与缺点
非 Docker 方案优点：
**实现简单直观：**直接在主机上配置 Nginx 和 PM2 即可，无需学习容器相关知识，适合现有部署方式的延续和小规模团队使用。运维人员可以方便地通过文件系统和常规Linux命令查看和管理应用状态。
**性能开销低：**没有容器化导致的额外抽象层，应用直接运行在宿主机上。本方案减少了一层Docker的资源开销（尽管Docker本身性能损耗不大，但省略容器能让IO、网络少一道转发）。对于资源紧张的单机，直接部署或许能多挤出一些性能。
**调试和问题排查方便：**日志、进程都在本地，出了问题可以马上SSH上服务器tail -f日志，或者直接 attach 调试 Node 进程。不会遇到容器网络或卷挂载问题，对于传统运维人员来说排错成本较低。
**部署灵活：**可以轻易地对某个文件打补丁、修改配置然后重启服务。无须重新构建镜像，适合快速试错。对于非常熟悉服务器环境的人来说，自由度更高。
**少层依赖：**不需要依赖Docker Engine，避免了Docker服务自身的升级、安全漏洞等管理。特别是在有些内网环境下Docker拉取镜像可能不便，而直接部署受制约更少。
非 Docker 方案缺点：
**环境一致性较差：**开发、测试、生产环境可能存在软件版本或配置差异。例如Node.js、npm、系统库版本不同，容易产生“在我电脑上没问题，上线就出问题”的情况。需要谨慎维护服务器环境，使其与开发环境一致。相比之下Docker可以封装统一环境。
**部署不可移植：**紧耦合于这台特定服务器。一旦需要迁移到新机器，必须重新配置环境、安装依赖、复制数据，过程繁琐且易出错。而Docker镜像迁移更方便。
**依赖管理复杂：**所有版本的应用共享操作系统和运行时环境，如果不同版本需要不同版本的系统库或全局依赖，处理起来麻烦。例如Python/Java等环境的版本冲突。Node.js一般用node_modules隔离还好，但例如两版本需要不同的全局nginx配置或不同的系统调优参数，无法隔离。
不便于扩展：如果以后需要扩展到多台服务器进行负载均衡，纯手工部署需要在每台机器重复设置。而Docker配合编排工具扩展则相对容易。此外，非Docker方案下CI/CD自动化程度可能不如容器方案流程化。
发布风险：直接在服务器上操作，可能因人为失误造成问题（例如误删文件、错误执行命令影响正在跑的服务）。虽然脚本可以规避一部分，但整体来说容错性不如容器方案（容器方案往往通过镜像immutable、防止直接改正在运行实例）。
综合来看，非Docker方案胜在上手容易，现有体系改造少，但在环境一致性和可移植性方面有所不足。对于团队成熟度和系统复杂度较低的场景，它是一个稳妥的选择。但如果追求更好的隔离和标准化，则可以考虑Docker方案。
方案二：基于 Docker 的多版本部署
在本方案中，我们使用 Docker 容器 来封装部署应用，将前后端及所需服务打包成容器镜像运行。通过 Docker 实现环境隔离和版本管理，辅以 Nginx 等组件实现多版本共存和流量控制。Docker方案本质上与非Docker方案架构类似，只是将应用进程运行在容器内，从而带来一些不同的部署方式和优劣权衡。
架构概览
Docker 部署架构下，一台 ECS 实例上会运行多个容器：分别对应生产版 Node.js 应用容器、测试版 Node.js 应用容器，以及所需的MongoDB容器和Nginx容器等。容器之间通过 Docker 网络通信，由Nginx容器充当反向代理（监听宿主80/443端口），将不同域名的请求转发给对应的应用容器。MongoDB可以作为一个独立容器提供数据库服务，并通过环境变量或配置分别为生产/测试提供不同的逻辑库。下图描述了Docker方案的大致结构：
**Nginx 容器：**作为前置反向代理，绑定宿主的80和443端口（通过端口映射或host模式）。该Nginx容器配置虚拟主机，实现与非Docker类似的基于域名路由：www.example.com 的请求代理到生产版应用容器，test.example.com 的请求代理到测试版应用容器。Nginx容器可以与应用容器共享一个Docker网络，通过容器名解析访问后端。
**生产版 Node.js 容器：**打包了生产环境的 Node.js 应用镜像（包含代码和运行时环境）。运行时暴露应用端口（例如容器内 3000），但不直接映射到宿主，而是仅供Nginx容器访问。容器内通过环境变量或配置文件指向生产数据库和其他生产配置。该容器可命名为 myapp_prod，方便Nginx配置和管理。
**测试版 Node.js 容器：**类似地，由同一应用的镜像启动另一容器实例作为测试环境（也可以用不同的镜像tag来区分版本）。容器内部仍监听3000端口（应用本身无需知道外部端口），在Docker网络下用容器名 myapp_test 区分，由Nginx代理定位。测试容器配置指向测试库等。这样在一台机上就有两个独立的应用容器实例运行。
**MongoDB 容器（可选）：**可以将 MongoDB 部署为一个Docker容器，将数据目录挂载到宿主。如果仅有一个MongoDB容器，那么生产和测试应用都连到这个容器（容器名比如mongo），再使用不同数据库名隔离数据（和非Docker方案一致，只是Mongo运行在容器中）。另一种选择是运行两个Mongo容器：一个供生产用，一个供测试用，各自挂载不同的数据卷，并暴露不同端口。但在单机环境下维护两套数据库开销较大，不是特别必要，通常一个容器多库已能满足。
**Docker Compose 编排：**建议使用 Docker Compose 来定义和管理上述多容器应用。通过一个 docker-compose.yml 文件，可以描述Nginx、应用、数据库等服务，以及它们的镜像、网络、卷、环境变量等配置。Compose 可以方便地启动或更新一组相关容器。示例简化的 Compose 配置：
version: '3'
services:
  nginx:
    image: nginx:1.25    # 使用官方nginx镜像
    container_name: myapp_nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/conf.d:/etc/nginx/conf.d:ro    # 挂载Nginx配置（包含域名路由设置）
      - ./certs:/etc/nginx/certs:ro           # SSL证书挂载
    networks:
      - myapp_net

  myapp_prod:
    image: myapp/image:latest    # 应用镜像
    container_name: myapp_prod
    environment:
      - NODE_ENV=production
      - MONGO_URL=mongodb://mongo/myapp_prod   # 指向mongo容器的生产库
    networks:
      - myapp_net

  myapp_test:
    image: myapp/image:latest    # 可使用同一镜像不同配置，也可以用特定tag镜像
    container_name: myapp_test
    environment:
      - NODE_ENV=staging
      - MONGO_URL=mongodb://mongo/myapp_test   # 测试库
    networks:
      - myapp_net

  mongo:
    image: mongo:6.0
    container_name: mongo
    volumes:
      - ./mongo_data:/data/db
    networks:
      - myapp_net
    # 默认mongo暴露27017端口在容器内，Compose下无需映射到宿主

networks:
  myapp_net:
    driver: bridge
上述 Compose 文件定义了一个Nginx服务和两个应用服务共用一个自定义网络myapp_net。Nginx可以通过容器名称解析到myapp_prod和myapp_test容器（这要求我们在挂载的Nginx配置中，把上游设置为 myapp_prod:3000 等）。生产和测试应用都连接同一个 mongo 容器，但使用不同数据库名。通过Compose，我们可以一条命令启动所有服务，也可以部分更新某个服务的镜像版本然后滚动重启，实现一定程度的编排。 **部署及运行：**运维人员只需维护Docker镜像和Compose配置，不直接接触应用进程。典型流程是：先构建或获取应用镜像（可以在CI中用 docker build 生成镜像，打上版本tag push到私有仓库），然后在服务器上用Compose拉取更新镜像并启动容器。Nginx容器因为配置中写死了域名转发关系，对应的应用容器名始终是myapp_prod和myapp_test两个。例如Nginx conf 可以写：
upstream app_prod { server myapp_prod:3000; }
upstream app_test { server myapp_test:3000; }

server {
    listen 80;
    server_name www.example.com;
    location / { proxy_pass http://app_prod; }
}
server {
    listen 80;
    server_name test.example.com;
    location / { proxy_pass http://app_test; }
}
这样Nginx通过Docker的DNS自动找到对应容器IP。
techannotation.wordpress.com
当需要蓝绿切换时，我们可以替换容器来实现（见下文版本切换部分）。 **资源隔离：**Docker利用Linux CGroups和Namespace提供了进程间隔离，各容器有各自的文件系统和依赖环境。例如生产和测试容器即使运行的是相同镜像，也各自有独立的内存空间和虚拟网络IP。容器之间不会直接干扰。此外，通过限制容器的CPU/内存，可以防止测试容器消耗过多资源影响生产容器。也可以对Mongo容器分配稳定的IO限额，保障数据库性能。当然在一台机上资源总量是固定的，隔离只是相对的，但Docker提供了比直接运行更好的控制粒度。
端口与路径规划
Docker方案下，外部端口仍然只暴露80和443。这一点通过Docker Compose或运行参数控制：Nginx容器将宿主的80/443映射过来，而应用容器和Mongo容器不需要映射端口到宿主（除非需要调试或远程访问）。这样，宿主层面看，只开启了Nginx的服务端口，对外依然干净统一。 **应用内部端口：**容器内的应用依然监听常规端口（如3000）。但由于每个应用在各自容器网络中，端口不冲突。因此生产和测试容器都可以使用容器内的3000端口。区分它们的是容器名称/网络IP。Nginx通过容器名把流量发到正确的容器的3000端口。所以应用镜像可以不因端口不同而修改配置，只需通过环境变量区分环境（如 NODE_ENV）。 文件路径与数据卷：容器镜像内部自带应用代码和默认配置。但像日志、上传文件、数据库数据这些需要持久化或区分环境的内容，我们可以使用卷 (Volume) 或 绑定挂载 来管理：
应用容器的日志目录可以挂载到宿主，例如将容器内 /usr/src/app/logs 挂载到宿主 /var/log/myapp/prod 或对应测试路径。这样日志在宿主统一管理，也可方便查看
blog.csdn.net
。或者使用Docker的日志驱动，把日志汇总到外部。
前端静态文件如果由Nginx直接服务，也可考虑将构建产物作为Volume提供给Nginx容器。例如构建时将静态文件打包进镜像（Nginx镜像），或在运行时挂载宿主目录。也可以前后端不分离地由Node容器提供静态文件，那么Nginx只管代理，不涉及路径配置。
MongoDB容器需要挂载数据卷以确保重启容器数据不丢。挂载路径区分一套Mongo或两套Mongo的情况。如果单Mongo容器，用一个数据卷即可（里面不同库的数据文件混在一起，但Mongo自身区分库）。如果两Mongo容器，则挂载不同路径比如 mongo_prod_data 和 mongo_test_data 分开。由于本方案假设单实例，一般用单Mongo足够。
镜像版本管理：可以使用不同的镜像标签来标识不同版本发布。例如 myapp:image:1.0-prod 和 myapp:image:1.0-test 两个镜像（虽然内容几乎相同，只是配置不同）。也可以用同一镜像运行不同容器，通过传不同环境变量达到不同行为。这取决于CI流程设计。如果希望严格区分生产发布镜像和测试镜像，可以在构建镜像时加Tag区分。 **Git 分支/Tag 配合：**CI/CD流水线可以设置：开发分支push后自动构建 :staging 标记的镜像并部署到测试容器；主干或Release Tag构建 :release 镜像用于生产部署
medium.com
。这样Docker镜像名本身就代表了版本来源，非常直观。同时宿主服务器上Compose文件或者部署脚本根据需要拉取相应Tag的镜像更新容器即可。对于手工模式，也可先在测试环境用docker build构建镜像试跑无误后，将镜像Tag重新标记为正式版再运行生产容器。这避免了在生产直接用未经验证的镜像。总之，通过镜像标签和仓库管理，可以灵活地管理多版本镜像并选择部署。 **目录结构：**使用Docker后，宿主上的目录主要用于存放Compose文件、配置和持久化数据。例如：
/opt/myapp-docker/
├── docker-compose.yml              # Compose文件
├── nginx/
│   └── conf.d/myapp.conf           # Nginx虚拟主机配置（代理规则）
├── certs/                          # SSL证书存放
├── prod.env                        # （可选）生产环境环境变量文件
├── test.env                        # （可选）测试环境环境变量文件
├── mongo_data/                     # MongoDB数据卷目录
└── logs/
    ├── prod/                       # 生产应用日志
    └── test/                       # 测试应用日志
这种结构清晰地把Docker相关的配置和数据集中管理。容器镜像本身不需要保存在某个目录，它由Docker引擎管理，但可以通过docker images看到版本。Compose文件把所有服务关系记录其中，可加入到版本控制。部署时按compose文件编排即可，一目了然。
部署流程与脚本模板
Docker方案的部署一般包括镜像构建和容器发布两个阶段： 1. 构建镜像（Build）： 先为应用编写Dockerfile，将Node.js应用打包成镜像（包括安装依赖、编译前端等步骤）。一个典型Dockerfile流程：使用 Node 官方基础镜像 -> 拷贝源码 -> npm install -> npm run build -> 设置 CMD ["npm","start"] 等。针对前后端，可以采用多阶段构建：先构建前端得到静态文件，再构建后端将前端文件一起COPY进后端服务等。如果前后端分离部署，也可以做两个镜像，一个Node API服务器镜像，一个Nginx静态文件镜像。这里为简单，假设我们构建一个包含前端静态文件的Node镜像或由Node服务静态。这部分视项目情况灵活对待。 镜像构建完成后，打上适当的标签推送到镜像仓库（比如Aliyun ACR或者Docker Hub私有库）。版本号或Git哈希作为tag以便回溯。
thomasbandt.com
在CI流程中可以自动完成这步，每次代码变更出一个新镜像。 2. 部署/更新容器： 在服务器上通过Docker或Compose启动容器。以Compose为例，运维可以执行：
docker-compose pull：拉取最新版本的应用镜像。
docker-compose up -d myapp_test：启动/更新测试版容器，让测试环境跑新镜像。或整个 up -d 启动所有服务。初次部署会启动Nginx、Mongo和应用容器。若compose配置未变化，只想更新镜像，也可用 docker-compose up -d --no-deps myapp_test 等。
检查日志和状态：docker-compose logs -f myapp_test 查看测试容器输出，确认没有错误。访问测试域名验证新版本功能。如果不通过，则可以停止该容器并回滚镜像版本。
待测试验证通过，准备更新生产容器：执行 docker-compose up -d myapp_prod 将生产容器切换到新镜像版本。由于我们采用蓝绿策略（见下节），可以考虑不直接替换生产容器，而是新启一个备用容器，然后切换Nginx流量，再停掉旧容器。这种更安全。标准的compose替换是会重启容器的，期间会有短暂停机，如果要无缝，需要借助下面介绍的蓝绿技巧。
**无Compose脚本示例：**也可以不用Compose，手工用docker命令控制，这里提供一个脚本片段说明蓝绿切换：
# 构建并推送镜像的步骤略。假设镜像myapp:v2已推送。
# 拉取新镜像并运行Green容器：
docker pull myrepo/myapp:v2
docker run -d --name myapp_green -e NODE_ENV=production \
  --network myapp_net myrepo/myapp:v2   # 新版本容器启动（监听3000端口）
# 检查健康
sleep 5
if ! docker exec myapp_green curl -sf http://localhost:3000/health; then
  echo "健康检查失败，新版本容器未正常启动。"
  docker logs myapp_green
  docker rm -f myapp_green
  exit 1
fi
# 更新Nginx配置将流量切到myapp_green容器（可以通过改变upstream指向容器名实现）:
sed -i 's/myapp_prod:3000;/myapp_green:3000;/' nginx/conf.d/myapp.conf
docker exec myapp_nginx nginx -s reload
echo "流量已切到新容器 myapp_green"
# 停止并移除旧的容器
docker rm -f myapp_prod
# 将新容器命名为正式容器名以备下次切换
docker rename myapp_green myapp_prod
此脚本思路与非Docker脚本类似，但操作对象变成容器：运行一个新容器实例供新版本，验证OK后修改Nginx上游指向它，然后删除旧容器
techannotation.wordpress.com
。最后rename确保容器名一致，方便今后脚本判断。这实现了容器级的蓝绿发布。实际应用中，也可以不rename，每次都识别当前活跃容器名以决定切换方向。 配置管理：Docker容器的配置通常通过环境变量传入。Compose文件可以用 .env 文件定义常量，在不同环境 docker-compose.yml 中引用。比如 NODE_ENV=production，MONGO_URL 等分别在prod和test环境给不同值。如上Compose示例已经体现。这使得同一个镜像可以根据环境变量行为有所区别（例如连不同DB）。也可以将配置文件挂载进去，不过Docker更提倡12-factor的环境变量配置方式以便镜像通用。 回滚：如果新镜像有问题，回滚也非常快捷：因为旧的镜像仍然存在，之前的容器也可以暂时保留（如蓝绿切换时保留旧容器一段时间）。最简单办法是：重启旧容器恢复流量，或者用旧版本镜像重新 run 一个容器接管。由于Docker镜像不可变，回滚相当于切换镜像标签而非改代码，这个过程很迅速。利用Compose，可能只需改回镜像tag然后 up -d 即可完成退版本（容器会重建启动旧版本应用）。
版本切换方式（蓝绿部署 / 灰度发布）
Docker部署同样支持蓝绿和灰度策略，并可以借助容器的灵活性进一步优化发布过程。 蓝绿部署：在Docker环境中，蓝绿模型通常体现为同时存在两个版本容器。正如前述脚本，当前生产流量在容器A (Blue) 上，新版本预备容器B (Green) 启动后，通过切换代理使其上位，然后关闭容器A
techannotation.wordpress.com
。由于使用容器，我们可以提前启动Green容器，让其完成冷启动和预热，再切流量时几乎不影响用户。具体技巧包括：
使用Docker Compose时，可以运行两套Compose服务配置，比如用不同的compose文件分别定义Blue和Green。或者在同一个Compose文件里定义两个应用服务（prod和test）但实际上用作蓝绿。切换时手工调整Nginx容器配置选择对应上游。
也可以不修改Nginx配置，而利用Docker容器的名称切换：例如，Nginx始终代理到名字为 myapp_active 的容器。发布新版本时，新容器启动取名 myapp_new，启动完成后，先将旧容器 myapp_active 改名为备份名，然后把 myapp_new 改名为 myapp_active，最后reload Nginx（如果Nginx解析的是容器名字，这需要重载或使用Docker service discovery）。这种方法可以实现切换，但Docker对运行中容器rename需要确保Nginx能及时解析更新，可能略繁琐，通常直接改Nginx配置更简单直观。
切换瞬间几乎无缝：因为Green容器早已跑在后台，没有连接Nginx而已。一旦Nginx转发给它，它立即接手请求。而旧容器仍在，处理已有连接或等待一段缓冲后再停。因此，可以实现真正零停机时间。Compose本身若直接up -d替换，可能会短暂停机，而蓝绿模式通过并行运行两个容器避免了这一点。
回滚同样快捷：只要在切换后一段时间内保留着旧容器未删，当检测新版本不稳定时，只需把Nginx指回旧容器IP/名称即可瞬时回滚
infoq.cn
。因此建议在发布后观察期内，不要马上销毁老版本容器。即使销毁了，有旧镜像在也能迅速重启一个容器来。
总的来说，Docker环境的蓝绿发布和非Docker思路一致，但容器使得环境切换更容易实现自动化。可以利用容器编排工具进一步简化这一流程，比如 Kubernetes 中有内置的蓝绿(滚动)发布特性。不过在我们单机场景，用compose和shell已经足够达成目的。 **灰度发布：**在容器环境中实施灰度发布通常需要借助负载均衡或服务网关。例如在Kubernetes可以用Ingress或Service配置流量百分比，在Docker环境下可以通过Nginx手工配置多个上游server实现。例如：
upstream app_all {
    server myapp_prod:3000 weight=80;
    server myapp_test:3000 weight=20;
}
server {
    listen 80;
    server_name www.example.com;
    location / {
       proxy_pass http://app_all;
    }
}
上例将生产容器和测试容器都作为上游，但设置不同权重
infoq.cn
。Nginx将按比率分配请求，实现约20%请求到测试容器（新版本），80%到生产容器（旧版本）。这是一种简单的金丝雀发布方法。当然Nginx的加权是基于每个请求，不是精确百分比，但对于大量请求场景近似可行。另外也可以通过Nginx $request_uri 或 $cookie 做 split_clients，精确划分某些用户比如根据hash值来路由，模拟A/B测试流量
infoq.cn
infoq.cn
。这个需要手写一些Nginx配置，但也不复杂。 在Docker方案中，由于同时跑着两个容器，通过Nginx灵活配置，我们比非Docker更容易让同一域名同时访问两套应用（因为它们都挂在Nginx后面）。非Docker其实也能，但Docker使得进程管理和识别更方便，不用考虑进程在不在——容器在就说明服务在。我们可以动态调整Nginx容器的配置来渐增新版本容器的流量占比。例如开始weight=1 (新) vs 9 (旧)，随后改成3 vs 7等等。这需要每次修改配置reload Nginx，过程可以写成脚本甚至用Nginx Plus API/动态上游管理（超出范围）。 **灰度控制粒度：**除了按比例，还可以按其他策略，例如让某一特定cookie的用户全量走新版本。这可以通过在Nginx配置中检测Cookie或Header，如果匹配则proxy_pass到新版本容器，否则默认旧版本。这样可以让内部测试人员通过特定浏览器配置体验新版本，而普通用户不受影响
blog.csdn.net
。也可以发布一个隐藏的测试URL给少数用户，它在Nginx里面直接指向新容器，其余用户还是正式域名指向旧容器。这些方法都属于灰度发布范畴。 灰度与蓝绿配合：如前所述，灰度更适合多实例大流量阶段。如果我们要在单机上做到极致，可以使用灰度+蓝绿：先让Green容器上线，但只给它一部分流量试运行（灰度），逐步扩大，当达到100%流量且稳定后，Green实际上就变成生产版本了，此时Blue空闲，可以下线。这相当于用灰度完成蓝绿切换。
infoq.cn
infoq.cn
不过在单机上，可能直接蓝绿切换已经能满足需求，灰度的作用更多是提供额外保险和测试阶段。如果业务对稳定性要求极高，可以考虑至少先在测试域名让新容器跑一下“假流量”（比如重放日志，或内部人员点击），算是一种预灰度，然后再蓝绿切换正式上线。
安全隔离措施
Docker 本身提供了一定程度的安全隔离，但在单机多容器部署中，仍需关注安全。主要措施包括： 1. 容器隔离：利用Docker的namespaces将应用运行环境隔离开。生产和测试应用各跑在自己的容器中，默认它们之间文件系统不可见。这避免了非Docker方案中一个应用进程可以直接操作全局文件的风险。即使测试容器被攻破，攻击者也进不去生产容器内部。容器之间通过网络通信也可受控，例如通过定义不同的Docker网络，如果需要也可以把生产和测试放不同网络（但Nginx需要同时访问，通常放同一网络即可）。总之，容器边界形成了安全墙。需要注意容器并非安全沙箱，如果宿主机root权限泄露容器也可能受影响，因此仍要遵守宿主的安全防护。 2. 端口和网络：Docker Compose默认自建的bridge网络对外不可见，只能通过映射端口访问容器。我们只映射了Nginx的80/443，所以其他容器（Node和Mongo）的端口不会暴露在宿主网络上，外界无法直接连接。这和非Docker下通过防火墙限制效果类似，但更省事，因为Docker默认就隔离了内部网络和外部。MongoDB容器没有映射27017端口到宿主，则完全不可能被公网扫描到端口。当然，如果需要远程DB管理，可以临时映射或开启SSH隧道。
内部通信方面，Nginx和应用容器在同一网络，可以互访。可以考虑启用Docker网络的加密（compose v3可以配置driver_opt or use overlay network with encryption if Swarm），但单机bridge一般明文也问题不大，毕竟都在localhost内部。关键是不要把容器直接--net=host暴露除Nginx外的服务。Nginx容器可以跑在host模式减少网络层转发开销，但这样它就和宿主共用网络空间，注意防护配置。同理，容器不要使用 --privileged 权限运行生产应用容器，保持least privilege。 **3. 数据管理：**MongoDB数据卷中的内容相当敏感，要注意宿主上权限设置。因为通过卷，数据存在宿主文件系统上，可能被宿主上的用户直接读取到。如果宿主有人有权限就涉及内控问题。通常这台ECS只我们运维能登录，那就注意不要随便改数据库目录。定期备份数据卷内容，备份时也可以使用Mongo自带导出。
日志卷同理，妥善配置rotate和权限。Docker容器日志默认去docker日志驱动，如果挂载文件，需做好logrotate避免卷占满磁盘。 4. 镜像安全：选择官方基础镜像并及时更新，避免已知漏洞。使用镜像扫描工具检查应用镜像的安全性（漏洞依赖等）。生产镜像应做到最小化：不含开发调试工具，不暴露源码（编译成dist或bundle），不包含多余账号。可以采用多阶段构建丢弃源码和devDependencies。这样就算有人进容器，也很难利用容器做更多事情。
同时，给容器添加只读设置等：例如Nginx容器可以将文件系统mount为只读（除了日志缓存目录）。Node应用容器如果不需要写入，也可启动时加 --read-only。这样入侵者无法轻易修改容器文件系统。敏感信息通过环境变量提供也有泄露风险，要保证Docker API接口（docker.sock）不暴露，否则恶意容器可能通过访问宿主docker来提权
techannotation.wordpress.com
。我们的compose把docker.sock挂载给Nginx代理做动态解析时就提到了这个要注意
techannotation.wordpress.com
。不过一般场景不用jwilder/nginx-proxy这种高级玩法，就不需要暴露docker.sock。 **5. 访问控制与监控：**和非Docker一样，可对测试环境的Web接口加Basic Auth或IP限制，在Nginx配置中实现（这一点与容器无关，但一样可做）。
监控方面，可以使用容器监控工具（如Prometheus+cadvisor）监测各容器资源用量，以及应用本身的性能指标。这可以及时发现某个环境异常（比如测试环境进程失控不会拖垮生产因为有资源限制，但也要发现并处理）。
此外如果团队对Kubernetes等熟悉，未来可以平滑地从Docker Compose迁移，利用更强大的调度和安全功能（如Pod安全策略、网络策略等），不过这超出本文范围。 **6. Docker自身安全：**注意定期更新Docker引擎版本，修补安全漏洞。配置合理的用户组，不要随便给别人docker执行权限（有docker权限基本等于root）。在Aliyun ECS上，给Docker开放的远程API接口最好关掉（默认不开）。这些基础设施安全保证容器方案不会引入新的漏洞。
优点与缺点
Docker 方案优点：
环境一致性和可移植：“开发环境=生产环境”。通过镜像将应用所需环境封装，避免环境差异问题。只要有Docker的地方就能运行，同样的镜像可以在测试和生产确保行为一致。这大大减少了部署故障。
pm2.keymetrics.io
同时应用与服务器解耦，可迁移到其他机器或云服务，方便扩容或迁云。
**更好的隔离：**容器隔离使得多版本运行互不干扰。例如测试版安装的额外依赖库，不会影响生产版容器。资源上也可隔离控制。此外，容器对系统的修改（文件、依赖）都限制在容器内，宿主保持干净。这提高了系统稳定性和安全性。
**部署标准化&自动化：**借助Compose/镜像标签等，部署过程标准统一，不易出错。CI/CD可以很方便地流水线化，例如构建镜像->推送->触发部署脚本pull新镜像运行，实现持续部署。回滚也只需切换镜像tag，十分快捷。
medium.com
medium.com
 Docker Compose作为“基础的编排工具”上手简单，又能在需要时升级到更高级工具。
**扩展性：**如果将来需要把应用扩展到多实例甚至上容器编排平台（如阿里云ACK或Docker Swarm），当前Docker化的架构更容易平滑过渡。即便在单机，Docker也能模拟出多实例负载均衡的环境。例如想增加一个临时实例共享流量，只需多启动一个容器加入Nginx上游即可。对于灰度/压力测试等需求，可以弹性地起停容器做实验，而不用在宿主安装一堆临时服务。
**版本管理：**镜像可以作为版本的交付物，每个版本都有唯一的镜像ID，可回溯。相比传统部署很难说清服务器上跑的到底是哪一次构建的产物，有无本地改动，Docker镜像不可变更，确保了“一致性”。此外镜像仓库也能成为制品库。
**更好的资源利用监控：**Docker允许限制CPU、内存等，避免测试环境意外抢占资源影响生产。也易于监控每个容器的资源消耗，分析性能瓶颈。而传统方法两个进程的资源竞争不容易管控，一旦测试进程跑飞可能影响整机。
Docker 方案缺点：
**学习和维护成本：**团队需具备Docker相关知识。包括编写Dockerfile、管理容器和排查容器内问题。有时候调试容器比直接调试进程复杂一些（需要进入容器shell等）。对于不熟悉容器的运维，初期需要摸索，并处理例如卷权限、网络等新问题。
**部署复杂度稍高：**初次搭建Docker环境、写compose文件、配置容器健康检查等，会比原来直接用PM2多一些步骤。如果出现Docker服务异常，也需要排查（例如Docker daemon挂掉会导致所有容器停）。而本地部署的应用至少不依赖第三方服务。不过Docker近年相当成熟，这些问题不常见。
**性能开销：**容器化本身较轻量，但仍有轻微性能损失，比如通过bridge网络代理稍有延迟（几乎可以忽略，一般<1ms级别），读写文件如果用OverlayFS也稍有开销。此外镜像占用磁盘空间，需要管理旧镜像清理。对于内存非常紧张的ECS小实例，跑多个容器也许会更吃内存（因为每个Node进程本身也一样要内存，容器只是额外几个MB开销）。总体上现代Docker性能影响很小，但仍需关注如容器间交互的效率（可以优化网络模式等）。
单机Docker的高可用:
在单机场景，用Docker并不能自动避免单点故障。Docker本身也可能崩溃或者容器意外退出。当然，我们可以设置 restart: always 保证容器异常退出自动重启，但如果Docker服务宕掉就需要人工干预。非Docker时如果PM2进程退出，PM2也能拉起。两者稳定性类似，但要注意避免配置失误让容器不停重启。
**运维细节变化：**例如查看日志要用 docker logs 或挂载卷后查看，调优系统参数可能要在容器上设置。运维习惯需要调整。另外系统监控工具需要配置对容器的监控，否则可能看不到具体进程（因为进程在容器pid namespace）。
**额外考虑：**对于小型团队，小项目而言，Docker的引入需要一定投入，但长远看收益是标准化和可重复。阿里云也有针对容器的服务（如ACR镜像仓库、ACK Kubernetes服务）可以进一步简化管理。如果未来可能重构为微服务或扩容，则容器化是早做准备。在仅单实例的短期情况下，如果团队不熟悉Docker且发布不频繁，也可以暂时沿用传统方案。但总体趋势Docker/容器已经是主流，建议逐步掌握并采用。
两种方案优劣对比
最后，对非Docker方案和Docker方案的特点进行总结对比，便于根据实际需求选择最佳实践：
**环境隔离：**Docker方案通过容器提供更彻底的隔离（文件系统、网络、依赖），安全性稍好，且环境一致性强。
pm2.keymetrics.io
非Docker方案依赖人为约定和进程管理，可能出现环境差异或干扰，但实现简单。
**部署与切换复杂度：**非Docker方案直接操作进程和文件，人工步骤稍多，但概念直观（适合已有手工发布流程）。Docker方案借助Compose脚本化发布，初始配置略复杂，但一旦配置好，后续发布基本一条命令搞定，蓝绿和灰度也更易实施自动化。
**资源利用：**在单机固定资源下，两方案运行两套应用都是占用双倍资源。Docker额外开销轻微，可忽略不计。但Docker可以更精细地限制资源和观察瓶颈，这在资源紧张时有帮助。非Docker用系统级工具也能监控但不如容器分得清楚。
**学习曲线：**非Docker对开发运维要求低，团队容易掌握。Docker需要学习镜像构建、容器管理等，但这也是当今DevOps必备技能。短期项目若人手不足，非Docker见效快；长期看Docker能提升DevOps效率和可靠性。
**持续交付：**如果计划建立CI/CD流水，Docker镜像作为交付物更标准化，适合流水线操作。非Docker也能用脚本实现CI，但容易受环境变化影响。
**排错调试：**非Docker可直接SSH上去调试进程或修改配置即时生效。Docker里调试需要进入容器或者修改后重建镜像，理论上不鼓励直接改容器内部。但也可以通过docker exec进入容器排查。整体上开发熟悉哪种方式要看团队背景。
**扩展弹性：**如果未来要扩展到多台机器或上云原生平台，Docker方案无疑更友好，迁移和扩容几乎不用改架构。非Docker则需要重新配置新机器环境，应用迁移也复杂。
**安全与维护：**Docker减少了在宿主安装各种服务（降低宿主被破坏风险），但增加了Docker daemon这个需要维护的点。非Docker则所有东西都跑在宿主，更需注意权限和进程管理安全（比如别让测试进程开debug端口被扫到）。各有侧重。
总结建议：如果团队已经在使用 PM2+Nginx 方式且运转正常，短期内可以按本文非Docker方案改进，迅速实现多版本共存和基本的蓝绿发布。着重在Nginx和PM2脚本上下功夫即可，不用引入新技术。如果追求更加标准化、自动化的部署，特别是希望减少将来运维负担、为更多环境做准备，那么Docker方案值得考虑。可以先在测试环境试行Docker容器化，积累经验，再逐步将生产发布切换到Docker方式。一开始也可两套方案并行（例如测试用Docker，生产先保留老方式，待成熟后全部Docker化）。 无论哪种方案，实现生产与测试环境隔离并可并行运行都是第一步目标。在此基础上，再实施蓝绿部署确保发布零停机，以及灰度发布降低风险。两种方案在这些目标上思路一致，只是实现手段不同。选择方案时，应根据团队技能栈、项目规模和未来规划来决定，并且充分测试方案的各项功能（如切换脚本、回滚流程）确保可靠。 希望通过本文的多版本部署手册，能帮助您在单机环境下搭建起完善的生产/测试并存体系，实现快速、安全的版本发布迭代！祝部署顺利！
blog.csdn.net
infoq.cn






源
您说：
给我docker部署的详细的手把手操作方案
ChatGPT 说：
你希望的 docker 手把手部署方案，请问目标环境包括以下哪些内容？

是否已安装 Docker 和 Docker Compose？是否需要我包含安装步骤？

前后端是分开镜像构建，还是统一一个镜像托管前后端？

你是希望部署到生产域名（含HTTPS）还是临时测试环境（IP加端口）？

项目里是否已有 Dockerfile，还是我需要为你生成标准 Dockerfile？

确认这些后，我会给出从构建镜像、编写 docker-compose.yml、配置 Nginx、环境变量、启动脚本、蓝绿切换与日志管理的完整操作指南。

您说：
1. 还没安装。2 一个镜像托管前后是不是简单点。3 都贴我方案。4. 没有
ChatGPT 说：
收到，我将为你整理一套详细的 Docker 部署手把手操作方案，涵盖以下内容：

Docker 和 Docker Compose 的安装步骤（适配阿里云 ECS）

编写统一镜像的 Dockerfile，将 React 前端和 Node.js 后端集成在一个镜像中

编写 docker-compose.yml 文件，包含应用、MongoDB、Nginx（含SSL证书）

提供生产部署（含正式域名与 HTTPS）与测试部署（通过 IP+端口）两个方案

创建环境变量文件、日志目录、数据卷挂载等部署结构

提供一键构建、部署、切换版本的脚本

蓝绿发布方案支持，包含健康检查与回滚脚本

稍等片刻，我整理完将尽快发给你。

Research completed in 5m· 19 个源· 69 个搜索
手把手构建统一镜像的 Docker 多版本部署方案（含正式与测试）

Docker 部署手册（React+Node.js+MongoDB项目，阿里云ECS单实例）
以下方案面向阿里云ECS（单实例，Ubuntu/CentOS通用），采用 Docker 和 Docker Compose 实现项目容器化部署，包含测试环境与生产环境的完整步骤。步骤编号清晰，命令可直接复制执行。必要时引用官方文档说明方法原理。
一、服务器准备：安装 Docker 与 Docker Compose
更新系统并安装依赖（以 Ubuntu/CentOS 为例）：
# 更新系统包（Ubuntu/CentOS 均可使用）
sudo apt-get update && sudo apt-get upgrade -y    # Ubuntu/Debian
sudo yum update -y                                # CentOS/RHEL

# 安装常用工具
sudo apt-get install -y curl wget gnupg2 lsb-release ca-certificates    # Ubuntu/Debian
sudo yum install -y yum-utils                            # CentOS/RHEL
安装 Docker 引擎：
Ubuntu/Debian：配置 Docker 官方仓库后安装 Docker CE
digitalocean.com
：
# 添加 Docker GPG 密钥及仓库（以 Ubuntu 20.04 为例）
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository \
  "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
sudo apt-get update
sudo apt-get install -y docker-ce
安装完成后，启动并设置 Docker 开机自启：
sudo systemctl start docker
sudo systemctl enable docker
sudo systemctl status docker   # 确认 docker 服务正常运行
digitalocean.com
CentOS：推荐使用 Docker 官方安装脚本：
sudo yum check-update
curl -fsSL https://get.docker.com/ | sh
上述命令会自动安装最新版 Docker CE（包括 daemon 和客户端）。安装后启动并开机自启：
sudo systemctl start docker
sudo systemctl enable docker
sudo systemctl status docker   # 确认 docker 服务正常运行
digitalocean.com
安装 Docker Compose：
Docker Compose 从 v2 起作为 Docker CLI 插件安装。
使用仓库方式安装：
# Ubuntu/Debian
sudo apt-get update
sudo apt-get install -y docker-compose-plugin

# CentOS/RHEL/Fedora (支持DNF或YUM)
sudo yum update -y
sudo yum install -y docker-compose-plugin
安装后可通过 docker compose version 验证。
docs.docker.com
或手动下载安装（不推荐，需手动更新）：
DOCKER_CONFIG=${DOCKER_CONFIG:-$HOME/.docker}
mkdir -p $DOCKER_CONFIG/cli-plugins
curl -SL https://github.com/docker/compose/releases/download/v2.39.2/docker-compose-linux-x86_64 \
  -o $DOCKER_CONFIG/cli-plugins/docker-compose
chmod +x $DOCKER_CONFIG/cli-plugins/docker-compose
docker compose version
安装完成后，使用 docker compose（或docker-compose）命令管理多容器。
二、编写 Dockerfile（前后端合并镜像）
项目采用 React（前端）+Node.js（后端）。我们使用多阶段构建（multi-stage）将前端打包并与后端一起发布：
# Stage 1: 前端构建
FROM node:18 AS frontend-builder
WORKDIR /app
# 复制前端代码并安装依赖
COPY frontend/package.json frontend/package-lock.json ./frontend/
RUN cd frontend && npm install --production=false
# 构建前端静态文件
COPY frontend ./frontend
RUN cd frontend && npm run build

# Stage 2: 后端编译与合并
FROM node:18 AS backend-builder
WORKDIR /app
# 复制后端代码、编译
COPY backend/package.json backend/package-lock.json ./
RUN npm install --production=false
# 复制全部后端源代码
COPY backend ./backend
RUN npm run build   # 编译 TypeScript 输出到 dist/

# Stage 3: 运行时镜像
FROM node:18
WORKDIR /app
ENV NODE_ENV=production
# 安装生产依赖
COPY backend/package.json backend/package-lock.json ./
RUN npm ci --production
# 将编译后的后端文件复制过来
COPY --from=backend-builder /app/dist ./dist
# 将前端构建产物复制到后端的静态目录下
COPY --from=frontend-builder /app/frontend/build ./public
# 设置应用端口（与后端 .env 中 PORT 一致）
ENV PORT=5000
# 暴露端口
EXPOSE 5000
# 启动命令：运行编译后的后端应用
CMD ["node", "dist/server.js"]
上述 Dockerfile 首先构建前端（npm run build），然后构建后端（npm run build 输出至 dist/）。最终镜像包含编译后的后端代码和前端静态文件（复制到 public/ 目录，需后端代码中使用 express.static('public') 提供服务）。若后端代码默认不同，可调整静态文件路径。
三、编写 docker-compose.yml
创建 docker-compose.yml，定义服务和网络：
version: '3.8'
services:
  app:
    build: .
    image: myapp:latest
    container_name: myapp_app
    restart: always
    ports:
      - "5000:5000"   # 后端服务端口（测试环境可改为其他端口）
    environment:
      - NODE_ENV=production
      - PORT=5000
      - MONGODB_URI=mongodb://mongo:27017/summer_vacation_db
      - JWT_SECRET=${JWT_SECRET}           # 可从 .env 文件读取
      # ...其他后端环境变量
    depends_on:
      - mongo
    volumes:
      - ./logs:/app/logs          # 挂载日志目录（示例）
      - ./uploads:/app/public/uploads  # 挂载上传目录

  mongo:
    image: mongo:6.0
    container_name: myapp_mongo
    restart: always
    ports:
      - "27017:27017"    # 本地可选映射到 Host
    volumes:
      - mongo-data:/data/db   # 持久化数据库数据

  # 可选：在 Docker 内运行 Nginx 反向代理（生产环境推荐使用域名和 HTTPS）
  nginx:
    image: nginx:latest
    container_name: myapp_nginx
    restart: always
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./deployment/nginx.conf:/etc/nginx/conf.d/default.conf:ro
      - ./certs:/etc/letsencrypt   # 挂载证书目录
    depends_on:
      - app

volumes:
  mongo-data:
app 服务：基于上述 Dockerfile 构建，环境变量通过 .env 或 Compose 指定（示例使用 ${JWT_SECRET} 从 .env 文件读取）。ports 暴露容器 5000 端口到宿主机。volumes 将宿主机的 ./logs、./uploads 目录挂载到容器以持久化日志和上传文件（可根据实际目录调整）。
mongo 服务：使用官方 MongoDB 镜像，数据卷 mongo-data 持久化 /data/db。生产环境建议将 MongoDB 端口仅绑定到 localhost 或直接不映射端口，仅供应用内部访问。
nginx 服务（可选）：若选择将 Nginx 作为容器运行，在 ./deployment/nginx.conf 放置站点配置，挂载 ./certs 保存 Let's Encrypt 证书，配置详见后文。测试环境可省略 Nginx 服务，直接通过 app 服务的端口访问。
四、配置文件结构与挂载建议
.env 文件：在项目根目录下创建 .env（或 .env.production）文件，存放密钥和环境变量。例如：
# 后端环境变量 (.env)
NODE_ENV=production
PORT=5000
MONGODB_URI=mongodb://mongo:27017/summer_vacation_db
JWT_SECRET=your_super_secret_key
JWT_EXPIRES_IN=7d
CORS_ORIGIN=http://your-domain.com
UPLOAD_MAX_SIZE=10485760
UPLOAD_ALLOWED_TYPES=image/jpeg,image/png,...
在 docker-compose.yml 中使用 ${VAR} 引用 .env 中的值。前端环境变量（如 API 接口地址）在构建时可配置在 frontend/.env.production 或使用 REACT_APP_API_BASE_URL 指向后端域名（例如 https://your-domain.com/api）。
数据与日志挂载：
数据库数据：使用 Docker 卷挂载 MongoDB 数据目录（Compose 示例中 volumes: mongo-data:/data/db）。也可将宿主机目录如 - ./mongodb:/data/db 挂载到容器。
日志与上传文件：建议将应用日志和上传文件存储在宿主机目录（如上例将 ./logs、./uploads 挂载）。这样即使容器重启数据也不会丢失，便于备份和查看日志。
结构示例（宿主机 /opt/myapp/ 目录）：
/opt/myapp/
├─ logs/           # 应用日志挂载目录
├─ uploads/        # 上传文件目录
├─ certs/          # TLS 证书目录 (for Nginx)
├─ deployment/     # Nginx 配置等
│   └─ nginx.conf
├─ Dockerfile
├─ docker-compose.yml
└─ .env
五、测试环境部署（使用 IP+端口，无域名HTTPS）
测试环境无需域名与 HTTPS，简化配置：
启动服务：在服务器上进入项目根目录，执行：
docker-compose up -d --build
该命令会根据 Dockerfile 构建镜像，并启动 app 与 mongo 服务（如配置有 Nginx 服务也会一起启动）。
访问应用：等待容器启动完毕后，通过 http://<服务器IP>:5000 访问前端页面（假设后端 server.js 已配置将前端静态文件作为根路由输出）。如端口不同，可根据 docker-compose.yml 中 ports 进行访问。无需 HTTPS，直接使用 IP 即可访问 API（例如 http://<IP>:5000/api/...）。
数据与日志检查：确认 MongoDB 已启动并运行（docker ps 可见 mongo 容器；docker logs myapp_mongo），并检查 /opt/myapp/logs 目录下是否有应用日志输出。
六、生产环境部署（域名+HTTPS，Nginx+Let’s Encrypt）
生产环境要求使用域名并配置 HTTPS 加密，推荐使用 Nginx 反向代理与 Let’s Encrypt 自动申请证书。
配置域名解析：将域名（例如 app.example.com）解析到服务器公网 IP。
生成 Nginx 配置：在 deployment/nginx.conf 中编写 Nginx 站点配置，例如：
server {
    listen 80;
    server_name app.example.com;

    # 前端静态文件
    location / {
        root /app/public;
        try_files $uri $uri/ /index.html;
    }

    # 后端 API 转发
    location /api/ {
        proxy_pass http://app:5000/api/;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }

    # 文件上传代理
    location /uploads/ {
        proxy_pass http://app:5000/uploads/;
        client_max_body_size 50M;
    }
}
注意上例中 proxy_pass 的主机名 app 与 docker-compose.yml 中服务名一致（由于 Docker Compose 默认在同一网络内解析）。若使用宿主机 Nginx，则需替换为 http://127.0.0.1:5000。
启动 Nginx 与应用：
Docker 方式：docker-compose up -d nginx app mongo。Nginx 容器会加载上述配置，监听 80 端口。
宿主机方式：安装 Nginx 后，将上述配置文件放置在 /etc/nginx/conf.d/，并重载 Nginx。此时要确保 Nginx 主机上可以访问到 Docker 内的 app:5000（可通过 127.0.0.1、localhost 或 Docker 内部网络方式）。
申请并配置 HTTPS：使用 Let’s Encrypt 的 Certbot 工具自动申请证书
digitalocean.com
：
sudo apt-get install -y certbot    # 如未安装
sudo certbot --nginx -d app.example.com
该命令会自动编辑 Nginx 配置并重启，使 HTTPS 生效
digitalocean.com
。证书文件位于 /etc/letsencrypt/live/app.example.com/，Nginx 已配置自动加载 fullchain.pem 与 privkey.pem。请确保防火墙开放了 TCP 443 端口（可参考
digitalocean.com
调整 UFW 规则）。申请成功后，访问 https://app.example.com 即可通过 HTTPS 访问应用。
HTTPS 强制跳转（可选）：Certbot 会询问是否启用 HTTP->HTTPS 强制重定向。选择“Redirect”即可自动配置。也可手动在 Nginx 加入：
server {
  listen 80;
  server_name app.example.com;
  return 301 https://$host$request_uri;
}
server {
  listen 443 ssl;
  server_name app.example.com;
  # ...SSL证书路径设置...
  # ...与上述配置相同...
}
最终 Nginx 会同时监听 80 和 443，使所有流量都走 HTTPS 加密通道。
七、蓝绿部署方案（Zero-Downtime）
蓝绿部署通过同时保留两个版本环境（如蓝蓝部署 Blue/Green），避免停机。我们可以采用如下思路
maptiler.com
maptiler.com
：
环境准备：为两个版本分别准备独立的服务组（例如 app-blue 与 app-green）。可通过在 docker-compose 文件中使用不同项目名或端口来区分：
蓝版本（Blue）：如将后端端口映射 5000:5000，Nginx 配置反向到 app_blue:5000；
绿版本（Green）：如使用端口 5001:5000（容器仍监听 5000，宿主机映射到 5001），Nginx 配置反向到 app_green:5001。
部署流程：假设当前线上正在运行蓝版本（Nginx 指向蓝环境）。发布新版本时：
使用新镜像启动绿版本容器：docker-compose -p green up -d，或 docker run --name app-green ... 等，让 app-green 服务独立运行。
验证绿环境健康并无误（可访问 http://服务器IP:5001）。
更新 Nginx 配置，将流量切换到 app-green（修改 proxy_pass 指向 app_green:5001），然后重载 Nginx。此时所有用户切换到新版本。
停止并移除蓝版本容器：docker-compose -p blue down（或 docker stop/rm），释放资源。
Nginx 原子切换：由于 Nginx 支持无缝重载，通过先在新版本成功后切换配置，再停止旧版本，可实现流量零中断
maptiler.com
maptiler.com
。可参考 MapTiler 教程 的示例。
示例命令：
# 启动绿版本
docker-compose -p green up -d --build
# 验证无误后切换 Nginx 指向 green:5000
# 重载 Nginx
docker exec myapp_nginx nginx -s reload
# 停止蓝版本
docker-compose -p blue down
八、一键脚本（自动构建、部署、回滚）
为简化操作，可编写脚本实现一键构建、部署和快速回滚示例：
build_and_deploy.sh（构建并部署）：
#!/bin/bash
# 构建镜像并后台启动服务
docker-compose build
docker-compose up -d
rollback.sh（回滚到上一版本）：
#!/bin/bash
# 假设之前已将旧版本镜像保留为 tag "previous"
# 回滚示例：重置latest到previous并重启
docker image tag myapp:previous myapp:latest
docker-compose down
docker-compose up -d
回滚原理：保留上一版本的镜像标签（例如 myapp:previous）。若新版本出现问题，可将旧标签重命名为 latest，然后重新 docker-compose up -d 启动旧版本服务。
脚本文件放在项目根目录，并赋予可执行权限：
chmod +x build_and_deploy.sh rollback.sh
执行后即可自动化完成发布或回滚流程。
参考文献：
Docker 官方安装指南
digitalocean.com
digitalocean.com
docs.docker.com
Let's Encrypt 与 Nginx 指南
digitalocean.com
蓝绿部署示例
maptiler.com
maptiler.com
以上内容涵盖从环境准备、编写 Dockerfile 与 Compose，到测试/生产部署、HTTPS 配置、蓝绿部署、以及一键脚本，确保完整、可复制地将当前 React+Node.js+MongoDB 项目迁移到 Docker 化部署环境。




源


未选择任何文件未选择任何文件
ChatGPT 也可能会犯错。请核查重要信息。

Docker 部署手册（React+Node.js+MongoDB项目，阿里云ECS单实例）
以下方案面向阿里云ECS（单实例，Ubuntu/CentOS通用），采用 Docker 和 Docker Compose 实现项目容器化部署，包含测试环境与生产环境的完整步骤。步骤编号清晰，命令可直接复制执行。必要时引用官方文档说明方法原理。
一、服务器准备：安装 Docker 与 Docker Compose
更新系统并安装依赖（以 Ubuntu/CentOS 为例）：
# 更新系统包（Ubuntu/CentOS 均可使用）
sudo apt-get update && sudo apt-get upgrade -y    # Ubuntu/Debian
sudo yum update -y                                # CentOS/RHEL

# 安装常用工具
sudo apt-get install -y curl wget gnupg2 lsb-release ca-certificates    # Ubuntu/Debian
sudo yum install -y yum-utils                            # CentOS/RHEL
安装 Docker 引擎：
Ubuntu/Debian：配置 Docker 官方仓库后安装 Docker CE
digitalocean.com
：
# 添加 Docker GPG 密钥及仓库（以 Ubuntu 20.04 为例）
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository \
  "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
sudo apt-get update
sudo apt-get install -y docker-ce
安装完成后，启动并设置 Docker 开机自启：
sudo systemctl start docker
sudo systemctl enable docker
sudo systemctl status docker   # 确认 docker 服务正常运行
digitalocean.com
CentOS：推荐使用 Docker 官方安装脚本：
sudo yum check-update
curl -fsSL https://get.docker.com/ | sh
上述命令会自动安装最新版 Docker CE（包括 daemon 和客户端）。安装后启动并开机自启：
sudo systemctl start docker
sudo systemctl enable docker
sudo systemctl status docker   # 确认 docker 服务正常运行
digitalocean.com
安装 Docker Compose：
Docker Compose 从 v2 起作为 Docker CLI 插件安装。
使用仓库方式安装：
# Ubuntu/Debian
sudo apt-get update
sudo apt-get install -y docker-compose-plugin

# CentOS/RHEL/Fedora (支持DNF或YUM)
sudo yum update -y
sudo yum install -y docker-compose-plugin
安装后可通过 docker compose version 验证。
docs.docker.com
或手动下载安装（不推荐，需手动更新）：
DOCKER_CONFIG=${DOCKER_CONFIG:-$HOME/.docker}
mkdir -p $DOCKER_CONFIG/cli-plugins
curl -SL https://github.com/docker/compose/releases/download/v2.39.2/docker-compose-linux-x86_64 \
  -o $DOCKER_CONFIG/cli-plugins/docker-compose
chmod +x $DOCKER_CONFIG/cli-plugins/docker-compose
docker compose version
安装完成后，使用 docker compose（或docker-compose）命令管理多容器。
二、编写 Dockerfile（前后端合并镜像）
项目采用 React（前端）+Node.js（后端）。我们使用多阶段构建（multi-stage）将前端打包并与后端一起发布：
# Stage 1: 前端构建
FROM node:18 AS frontend-builder
WORKDIR /app
# 复制前端代码并安装依赖
COPY frontend/package.json frontend/package-lock.json ./frontend/
RUN cd frontend && npm install --production=false
# 构建前端静态文件
COPY frontend ./frontend
RUN cd frontend && npm run build

# Stage 2: 后端编译与合并
FROM node:18 AS backend-builder
WORKDIR /app
# 复制后端代码、编译
COPY backend/package.json backend/package-lock.json ./
RUN npm install --production=false
# 复制全部后端源代码
COPY backend ./backend
RUN npm run build   # 编译 TypeScript 输出到 dist/

# Stage 3: 运行时镜像
FROM node:18
WORKDIR /app
ENV NODE_ENV=production
# 安装生产依赖
COPY backend/package.json backend/package-lock.json ./
RUN npm ci --production
# 将编译后的后端文件复制过来
COPY --from=backend-builder /app/dist ./dist
# 将前端构建产物复制到后端的静态目录下
COPY --from=frontend-builder /app/frontend/build ./public
# 设置应用端口（与后端 .env 中 PORT 一致）
ENV PORT=5000
# 暴露端口
EXPOSE 5000
# 启动命令：运行编译后的后端应用
CMD ["node", "dist/server.js"]
上述 Dockerfile 首先构建前端（npm run build），然后构建后端（npm run build 输出至 dist/）。最终镜像包含编译后的后端代码和前端静态文件（复制到 public/ 目录，需后端代码中使用 express.static('public') 提供服务）。若后端代码默认不同，可调整静态文件路径。
三、编写 docker-compose.yml
创建 docker-compose.yml，定义服务和网络：
version: '3.8'
services:
  app:
    build: .
    image: myapp:latest
    container_name: myapp_app
    restart: always
    ports:
      - "5000:5000"   # 后端服务端口（测试环境可改为其他端口）
    environment:
      - NODE_ENV=production
      - PORT=5000
      - MONGODB_URI=mongodb://mongo:27017/summer_vacation_db
      - JWT_SECRET=${JWT_SECRET}           # 可从 .env 文件读取
      # ...其他后端环境变量
    depends_on:
      - mongo
    volumes:
      - ./logs:/app/logs          # 挂载日志目录（示例）
      - ./uploads:/app/public/uploads  # 挂载上传目录

  mongo:
    image: mongo:6.0
    container_name: myapp_mongo
    restart: always
    ports:
      - "27017:27017"    # 本地可选映射到 Host
    volumes:
      - mongo-data:/data/db   # 持久化数据库数据

  # 可选：在 Docker 内运行 Nginx 反向代理（生产环境推荐使用域名和 HTTPS）
  nginx:
    image: nginx:latest
    container_name: myapp_nginx
    restart: always
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./deployment/nginx.conf:/etc/nginx/conf.d/default.conf:ro
      - ./certs:/etc/letsencrypt   # 挂载证书目录
    depends_on:
      - app

volumes:
  mongo-data:
app 服务：基于上述 Dockerfile 构建，环境变量通过 .env 或 Compose 指定（示例使用 ${JWT_SECRET} 从 .env 文件读取）。ports 暴露容器 5000 端口到宿主机。volumes 将宿主机的 ./logs、./uploads 目录挂载到容器以持久化日志和上传文件（可根据实际目录调整）。
mongo 服务：使用官方 MongoDB 镜像，数据卷 mongo-data 持久化 /data/db。生产环境建议将 MongoDB 端口仅绑定到 localhost 或直接不映射端口，仅供应用内部访问。
nginx 服务（可选）：若选择将 Nginx 作为容器运行，在 ./deployment/nginx.conf 放置站点配置，挂载 ./certs 保存 Let's Encrypt 证书，配置详见后文。测试环境可省略 Nginx 服务，直接通过 app 服务的端口访问。
四、配置文件结构与挂载建议
.env 文件：在项目根目录下创建 .env（或 .env.production）文件，存放密钥和环境变量。例如：
# 后端环境变量 (.env)
NODE_ENV=production
PORT=5000
MONGODB_URI=mongodb://mongo:27017/summer_vacation_db
JWT_SECRET=your_super_secret_key
JWT_EXPIRES_IN=7d
CORS_ORIGIN=http://your-domain.com
UPLOAD_MAX_SIZE=10485760
UPLOAD_ALLOWED_TYPES=image/jpeg,image/png,...
在 docker-compose.yml 中使用 ${VAR} 引用 .env 中的值。前端环境变量（如 API 接口地址）在构建时可配置在 frontend/.env.production 或使用 REACT_APP_API_BASE_URL 指向后端域名（例如 https://your-domain.com/api）。
数据与日志挂载：
数据库数据：使用 Docker 卷挂载 MongoDB 数据目录（Compose 示例中 volumes: mongo-data:/data/db）。也可将宿主机目录如 - ./mongodb:/data/db 挂载到容器。
日志与上传文件：建议将应用日志和上传文件存储在宿主机目录（如上例将 ./logs、./uploads 挂载）。这样即使容器重启数据也不会丢失，便于备份和查看日志。
结构示例（宿主机 /opt/myapp/ 目录）：
/opt/myapp/
├─ logs/           # 应用日志挂载目录
├─ uploads/        # 上传文件目录
├─ certs/          # TLS 证书目录 (for Nginx)
├─ deployment/     # Nginx 配置等
│   └─ nginx.conf
├─ Dockerfile
├─ docker-compose.yml
└─ .env
五、测试环境部署（使用 IP+端口，无域名HTTPS）
测试环境无需域名与 HTTPS，简化配置：
启动服务：在服务器上进入项目根目录，执行：
docker-compose up -d --build
该命令会根据 Dockerfile 构建镜像，并启动 app 与 mongo 服务（如配置有 Nginx 服务也会一起启动）。
访问应用：等待容器启动完毕后，通过 http://<服务器IP>:5000 访问前端页面（假设后端 server.js 已配置将前端静态文件作为根路由输出）。如端口不同，可根据 docker-compose.yml 中 ports 进行访问。无需 HTTPS，直接使用 IP 即可访问 API（例如 http://<IP>:5000/api/...）。
数据与日志检查：确认 MongoDB 已启动并运行（docker ps 可见 mongo 容器；docker logs myapp_mongo），并检查 /opt/myapp/logs 目录下是否有应用日志输出。
六、生产环境部署（域名+HTTPS，Nginx+Let’s Encrypt）
生产环境要求使用域名并配置 HTTPS 加密，推荐使用 Nginx 反向代理与 Let’s Encrypt 自动申请证书。
配置域名解析：将域名（例如 app.example.com）解析到服务器公网 IP。
生成 Nginx 配置：在 deployment/nginx.conf 中编写 Nginx 站点配置，例如：
server {
    listen 80;
    server_name app.example.com;

    # 前端静态文件
    location / {
        root /app/public;
        try_files $uri $uri/ /index.html;
    }

    # 后端 API 转发
    location /api/ {
        proxy_pass http://app:5000/api/;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }

    # 文件上传代理
    location /uploads/ {
        proxy_pass http://app:5000/uploads/;
        client_max_body_size 50M;
    }
}
注意上例中 proxy_pass 的主机名 app 与 docker-compose.yml 中服务名一致（由于 Docker Compose 默认在同一网络内解析）。若使用宿主机 Nginx，则需替换为 http://127.0.0.1:5000。
启动 Nginx 与应用：
Docker 方式：docker-compose up -d nginx app mongo。Nginx 容器会加载上述配置，监听 80 端口。
宿主机方式：安装 Nginx 后，将上述配置文件放置在 /etc/nginx/conf.d/，并重载 Nginx。此时要确保 Nginx 主机上可以访问到 Docker 内的 app:5000（可通过 127.0.0.1、localhost 或 Docker 内部网络方式）。
申请并配置 HTTPS：使用 Let’s Encrypt 的 Certbot 工具自动申请证书
digitalocean.com
：
sudo apt-get install -y certbot    # 如未安装
sudo certbot --nginx -d app.example.com
该命令会自动编辑 Nginx 配置并重启，使 HTTPS 生效
digitalocean.com
。证书文件位于 /etc/letsencrypt/live/app.example.com/，Nginx 已配置自动加载 fullchain.pem 与 privkey.pem。请确保防火墙开放了 TCP 443 端口（可参考
digitalocean.com
调整 UFW 规则）。申请成功后，访问 https://app.example.com 即可通过 HTTPS 访问应用。
HTTPS 强制跳转（可选）：Certbot 会询问是否启用 HTTP->HTTPS 强制重定向。选择“Redirect”即可自动配置。也可手动在 Nginx 加入：
server {
  listen 80;
  server_name app.example.com;
  return 301 https://$host$request_uri;
}
server {
  listen 443 ssl;
  server_name app.example.com;
  # ...SSL证书路径设置...
  # ...与上述配置相同...
}
最终 Nginx 会同时监听 80 和 443，使所有流量都走 HTTPS 加密通道。
七、蓝绿部署方案（Zero-Downtime）
蓝绿部署通过同时保留两个版本环境（如蓝蓝部署 Blue/Green），避免停机。我们可以采用如下思路
maptiler.com
maptiler.com
：
环境准备：为两个版本分别准备独立的服务组（例如 app-blue 与 app-green）。可通过在 docker-compose 文件中使用不同项目名或端口来区分：
蓝版本（Blue）：如将后端端口映射 5000:5000，Nginx 配置反向到 app_blue:5000；
绿版本（Green）：如使用端口 5001:5000（容器仍监听 5000，宿主机映射到 5001），Nginx 配置反向到 app_green:5001。
部署流程：假设当前线上正在运行蓝版本（Nginx 指向蓝环境）。发布新版本时：
使用新镜像启动绿版本容器：docker-compose -p green up -d，或 docker run --name app-green ... 等，让 app-green 服务独立运行。
验证绿环境健康并无误（可访问 http://服务器IP:5001）。
更新 Nginx 配置，将流量切换到 app-green（修改 proxy_pass 指向 app_green:5001），然后重载 Nginx。此时所有用户切换到新版本。
停止并移除蓝版本容器：docker-compose -p blue down（或 docker stop/rm），释放资源。
Nginx 原子切换：由于 Nginx 支持无缝重载，通过先在新版本成功后切换配置，再停止旧版本，可实现流量零中断
maptiler.com
maptiler.com
。可参考 MapTiler 教程 的示例。
示例命令：
# 启动绿版本
docker-compose -p green up -d --build
# 验证无误后切换 Nginx 指向 green:5000
# 重载 Nginx
docker exec myapp_nginx nginx -s reload
# 停止蓝版本
docker-compose -p blue down
八、一键脚本（自动构建、部署、回滚）
为简化操作，可编写脚本实现一键构建、部署和快速回滚示例：
build_and_deploy.sh（构建并部署）：
#!/bin/bash
# 构建镜像并后台启动服务
docker-compose build
docker-compose up -d
rollback.sh（回滚到上一版本）：
#!/bin/bash
# 假设之前已将旧版本镜像保留为 tag "previous"
# 回滚示例：重置latest到previous并重启
docker image tag myapp:previous myapp:latest
docker-compose down
docker-compose up -d
回滚原理：保留上一版本的镜像标签（例如 myapp:previous）。若新版本出现问题，可将旧标签重命名为 latest，然后重新 docker-compose up -d 启动旧版本服务。
脚本文件放在项目根目录，并赋予可执行权限：
chmod +x build_and_deploy.sh rollback.sh
执行后即可自动化完成发布或回滚流程。
参考文献：
Docker 官方安装指南
digitalocean.com
digitalocean.com
docs.docker.com
Let's Encrypt 与 Nginx 指南
digitalocean.com
蓝绿部署示例
maptiler.com
maptiler.com
以上内容涵盖从环境准备、编写 Dockerfile 与 Compose，到测试/生产部署、HTTPS 配置、蓝绿部署、以及一键脚本，确保完整、可复制地将当前 React+Node.js+MongoDB 项目迁移到 Docker 化部署环境。
引用

How To Install and Use Docker on Ubuntu | DigitalOcean

https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-20-04

How To Install and Use Docker on CentOS 7 | DigitalOcean

https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-centos-7

Plugin | Docker Docs

https://docs.docker.com/compose/install/linux/

How To Secure Nginx with Let's Encrypt on Ubuntu | DigitalOcean

https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-20-04

How To Secure Nginx with Let's Encrypt on Ubuntu | DigitalOcean

https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-20-04
Blue-Green Deployment with Docker and Nginx | MapTiler

https://www.maptiler.com/news/2016/08/blue-green-deployment-with-docker-and-nginx/
Blue-Green Deployment with Docker and Nginx | MapTiler

https://www.maptiler.com/news/2016/08/blue-green-deployment-with-docker-and-nginx/
全部来源

digitalocean

docs.docker
maptiler