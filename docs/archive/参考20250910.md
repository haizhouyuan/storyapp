跳至内容
历史聊天记录

您说：
我需要你帮我做一个每日睡前互动故事app。先做一个demo
由用户输入主题，AI来互动完成故事生成，你来为我设计，并且给我给figmamake的提示词，直接让他来给我构建，我可以直接发布并使用的，api用deepseek3.1的
ChatGPT 说：
好的，我可以帮你设计一个每日睡前互动故事App的demo。为了确保Figma原型贴合你的需求，请问你能确认以下几点吗：

你希望App的核心流程是什么？（例如：用户输入主题 → AI生成互动故事 → 用户选择分支 → 故事推进 → 完成）

是否需要用户登录或注册功能？

App目标用户是儿童、成人，还是其他人群？

是否需要音频播放/语音互动功能？

是否需要存档/收藏已生成的故事？

有没有配色风格或美术风格偏好？（如极简、童趣、柔和等）

确认这些细节后，我会生成完整的Figma提示词（Prompt），你可以直接粘贴到Figmamake中使用。

您说：
1. 是的。2. 不需要。3. 十岁的孩子，4. 需要。5 需要。6 童趣
ChatGPT 说：
太好了，我会为你设计一个适合十岁儿童的每日睡前互动故事App demo，包括以下内容：

用户输入主题

基于 DeepSeek-VL 3.1 的 AI 故事生成与互动流程

支持语音播放与互动

可以保存/收藏生成的故事

拥有童趣风格的界面

我会为你整理出完整的Figma提示词，供你在Figmamake中直接使用来搭建App原型。稍后我会把这些内容发给你，请稍等片刻。

Research completed in 3m· 7 个源· 51 个搜索
儿童睡前互动故事App Demo设计

儿童睡前互动故事App界面原型设计
界面结构概述
输入故事主题页： 应用首页供用户输入想听的故事主题。设计一个充满童趣的欢迎界面，引导儿童开始他们的故事之旅。
故事互动页： AI根据主题生成故事开头，用户在每个关键节点通过选择不同情节分支来推动故事发展。此页面会循环出现故事片段+选择，直到故事结束。
故事结束与保存： 当故事讲完时，提供选项将故事保存到“我的故事”。可以在故事结束画面显示保存按钮或提示。
我的故事页： 一个专门页面存放已保存的故事列表，包括每个故事的标题、创建日期和缩略图，供儿童随时重温他们喜欢的故事。
以上结构避免了复杂的导航层级，让儿童直观地完成创建-互动-保存-回顾的闭环体验
woshipm.com
。
页面布局设计建议
1. 输入故事主题页
整体布局： 页面采用温馨的插画背景，例如星空或童话森林，增添睡前氛围。顶部或中间放置可爱的插画（如拿着故事书的卡通动物），吸引儿童注意。
主题输入区域： 中央突出一个圆角输入框，默认文本提示“请输入你想听的故事主题…”。字体要足够大且易读，避免复杂字形。旁边可以有一个小图标点缀（如放大镜或魔法棒），提示可以点击生成故事。
开始按钮： 输入框下方放置一个醒目的大按钮，例如“开始讲故事”或“生成故事”，采用鲜艳但柔和的颜色区分于背景。按钮设计圆润且尺寸偏大，方便孩子点击
woshipm.com
。按钮上可搭配简洁易懂的图标（例如一个播放的三角形或书本形象），帮助不熟识文字的儿童理解功能
woshipm.com
。
我的故事入口： 界面角落放置“我的故事”入口按钮（比如一个小书本📖或星星⭐图标）。图标同样需要清晰直观，颜色与界面协调，让孩子知道可以点击查看已保存的故事
woshipm.com
。此入口不抢主次，放在角落确保首页核心任务仍是输入主题。
2. 故事互动页
故事展示区域： 页面上部以卡片或气泡对话形式展示故事文本。采用大号字、行间距舒适的段落呈现，搭配插画或情景插图增强趣味（例如故事主角形象的小插图）。每段故事文本旁提供一个语音播放按钮（小喇叭或小人朗读的图标），点击即可语音朗读当前段落，方便孩子聆听
woshipm.com
。文本区域背景用柔和浅色卡片衬底，圆角边框让视觉感受友好。
情节分支选择： 在每段故事讲完后，下方出现最多三个圆角选择按钮，供用户决定接下来情节的发展。每个选择按钮上简短文字描述选项，并可配相应的小图标/插画（例如选项内容涉及“城堡”，按钮上可有小城堡图标）。按钮布局竖向堆叠或网格排列，保证足够间距防止误触
woshipm.com
。色彩运用上，三个选项按钮可以用不同柔和颜色区分（如淡蓝、浅绿、淡橙），既吸引儿童注意又不至于过于刺眼。**注意：**一次只呈现当前一步的选项，避免信息过载
woshipm.com
。
交互反馈： 当孩子点击某个情节按钮后，可以有简单的动画反馈，例如按钮轻微放大或闪动，伴随“叮咚”音效，提示选择已生效。这种正向反馈有助于提高儿童的参与感
pixso.cn
woshipm.com
。然后故事区域加载下一段文字和插图。过程中界面保持简洁，没有多余功能打扰，孩子只专注于阅读/收听和选择这两件事。
辅助控件： 故事页顶端可设“返回首页”按钮（例如一个小房子🏠图标）以便随时退出当前故事；界面其它地方避免出现不相关的按钮或广告，保护儿童专注和安全
woshipm.com
。
3. 故事结束与保存
结束提示： 当故事分支走完，故事展示区域出现一个完结插画（如“晚安”的卡通场景，满足温馨收尾）以及“故事完结”标题性文字，庆祝孩子完成了一个故事。
保存按钮： 在完结信息下方，放置一个突出的大按钮“保存到我的故事”。按钮样式依然圆润童趣，颜色可以与首页开始按钮有所区别（例如使用金色或亮黄色表示奖励感）。按钮旁配以星形或书本带爱心的图标，强化“收藏故事”的含义。
操作反馈： 点击保存后，弹出简短提示（比如小弹窗或Toast，上有笑脸图案）：“故事已保存！”并提供“去我的故事查看”链接。这一反馈让儿童明白保存成功，并引导他们查看收藏内容。弹窗设计可爱不刺眼，3秒左右自动消失以免妨碍。
无账号设计： 因无需登录，保存操作在本地完成即可。界面文案和流程尽量简单直接，不出现登录/注册字样，确保儿童使用时不被干扰。
4. 我的故事页
列表布局： “我的故事”页主要部分是已保存故事的列表。每条故事条目设计成圆角卡片形式，列表可垂直滚动。卡片左侧放一个小缩略图/封面插画，右侧依次是故事标题和保存日期。
woshipm.com
建议缩略图采用故事相关的可爱插图，比如根据主题显示相应场景或主角（没有生成插画时可用统一的故事书封面图案代替）。缩略图形状统一（圆角矩形或圆形）保持版面整齐。
文本信息： 标题采用大号字体突出显示，简洁概括故事主题（用户输入的主题或AI生成的标题）。日期用较小字体标注在标题下方或旁边，颜色次要（灰色或浅色），帮助孩子和家长识别故事的新旧。
交互元素： 每个故事卡片整体可点击，点入后打开完整故事内容供再次阅读/收听。也可以在卡片右侧放一个播放按钮图标，表示直接播放故事音频。考虑儿童可能误触，播放按钮要有足够留白分隔。
woshipm.com
如需删除或管理故事，可将删除图标隐藏在卡片滑动操作中或由父母协助，避免儿童误删。
页面导航： 顶部显示页面标题“我的故事”，采用彩色卡通字体装饰。左上角提供返回首页的按钮（小房子图标），让孩子一键回到主题输入页。整个页面设计简洁明了，用色可以比故事页更静谧一点（象征收藏库的感觉），但仍保持童趣风格，使孩子感到亲切。
童趣UI视觉风格参考
色彩运用： 建议采用柔和的粉彩色调作为主色系，例如薄荷绿的天空、奶油白的云朵、温暖的浅黄色土地等梦幻配色，营造温馨氛围
liblib.art
。尽管儿童喜欢鲜艳颜色，但要避免纯度过高的刺眼色，选择高明度中等饱和度的颜色既丰富又柔和
woshipm.com
。界面不同元素可以使用多种缤纷颜色区分，但注意整体协调统一，不杂乱冲突
woshipm.com
。
字体与排版： 字体选择圆润、可爱的无衬线字体，确保清晰易读。中文可以考虑使用幼圆、学龄童体等风格；英文则Comic Sans等类似手写体常被用于儿童产品（但需平衡美观与可读性）。重要的是字号偏大、留白充足，让界面呼吸感好，文本信息一目了然。段落不要过长，多用短句或分段以符合儿童的阅读节奏
woshipm.com
。
图形与插画： 图标和插画风格应统一为2D扁平卡通或手绘风格。形状尽量简洁圆润，少用尖角直线，
liblib.art
提到可采用干净线条、圆润形状和柔和阴影来增添层次感。插画可参考儿童绘本的风格，人物和动物造型Q萌可爱，表情夸张明确，便于传达情绪。无轮廓线设计可以让画面更柔和
liblib.art
，必要的边界用浅色阴影或色块区分即可。
动画与动效： 适度的动画能提高趣味，例如页面切换时的卡片翻页效果，按钮点击时的轻微弹跳等。动效应轻盈短暂，确保不会让孩子分心或着迷于反复点击。语音播放时可在文本旁加入音量波动图标或小人物张嘴说话的动画，增强交互反馈
woshipm.com
。整体动效风格要活泼但不花哨，服务于提升儿童理解和操作的体验。
上述视觉和交互动效风格共同打造出充满童趣又井然有序的界面，让孩子既感到有趣，又能顺利地使用各项功能
woshipm.com
。
Figmamake 提示词示例
设计需求： 一款面向 10岁儿童 的 睡前互动故事App 界面原型设计。包含 输入故事主题页、AI互动讲故事页 和 我的故事页 三个主要界面，无需登录。
风格定位： 童趣温馨，采用柔和粉彩配色，圆润插画图标，界面简洁易懂。
页面1 - 输入故事主题页： 可爱的睡前插画背景，中间有圆角输入框（提示“请输入故事主题”），下方大号彩色按钮“开始讲故事”▶️。页面角落有“小书本”图标按钮，可进入“我的故事”列表。
页面2 - AI互动故事页： 顶部显示故事文本卡片，每段文字旁有🔊播放按钮。底部显示最多3个彩色圆角按钮供选择情节（按钮上有简短文字和小插画）。界面提供返回主页🏠按钮。布局简洁，元素偏大方便点击。
页面3 - 我的故事页： 列表形式展示已保存故事，每项包括圆角缩略图📖、故事标题（大字）和日期（小字）。页面顶部有标题“我的故事”和返回主页按钮。整体风格统一童趣，颜色丰富但柔和。
交互说明： 点击“开始”生成故事并进入故事页；在故事页选择选项加载下一段故事；故事结尾出现“保存故事”按钮⭐可将故事加入列表。所有按钮和图标需清晰易懂，适合儿童操作
woshipm.com
woshipm.com
。




源
您说：
儿童睡前故事App原型.zip
压缩归档
附件是figmamake设计的前端代码。这是figma发布的：
https://black-string-64883947.figma.site
后端和api怎么设计，数据库是figmamake自带集成supabase。我想让figmamake继续完成，你给我提示词
ChatGPT 说：
好的，我可以为你生成提示词让 Figmamake 完成后端和 API 接口的自动构建。为了确保对接 supabase 和 deepseek-3.1 的接口流畅运行，请确认以下几点：

你希望故事是每次都重新生成，还是也支持基于同一主题多次生成不同版本？

DeepSeek API 的接口地址和授权机制是否已确定？需要我帮你生成假数据接口结构供后端开发使用吗？

除了保存故事内容外，是否还需要记录用户选择的分支路径或互动行为？

是否支持语音文件存储？是使用第三方 TTS 服务（如 ElevenLabs、百度、Google）生成音频，还是你已有音频方案？

确认这些后，我会生成一套完整的 Figmamake 提示词，自动生成后端接口、supabase 表结构和 API 对接逻辑。

您说：
1. 重新生成，2. deepseek的官方apikey，不要假数据，直接用真实的来测试。3. 先不记录。4. tts部分先留空，我还没准备好api。
ChatGPT 说：
了解了，我将为你生成 Figmamake 提示词，用于自动创建完整的后端逻辑，包括：

使用 DeepSeek 3.1 官方 API 实时生成故事（用户输入主题即可）

将生成的故事内容存储在 Supabase 数据库中（无分支记录）

创建 API 路由供前端调用（如 /api/generate-story、/api/save-story）

留出 TTS 接口位，后续你可以补上调用第三方语音合成服务

我会为你输出结构清晰、可以直接贴入 Figmamake 的提示词，以完成后端和数据库的配置。

Research completed in 5m· 4 个源· 23 个搜索
睡前故事App后端与Supabase集成设计

儿童睡前互动故事App后端设计
API 接口设计
生成故事接口 (POST /api/generate-story)：用户提供故事主题（例如“恐龙和外星人”）作为请求参数topic。后端使用 DeepSeek-V3.1 官方 API （通过配置好的 API Key）生成一个故事开头段落，并给出最多三个后续情节分支建议。调用 DeepSeek 接口时使用stream=false以直接获取完整回复。接口返回一个JSON对象，包括生成的故事开头文本和分支情节建议列表。
保存故事接口 (POST /api/save-story)：当用户阅读完故事后，可通过此接口将故事保存到数据库“我的故事”。请求体提供JSON数据，包括title（故事标题或主题）、content（完整故事内容）以及created_at（保存时间，可以由后端自动生成当前时间）。后端收到请求后，将该数据保存到 Supabase 数据库的stories表中。数据库表stories结构：包含字段id（UUID，主键，自动生成）、title（文本，用于存储故事标题）、content（长文本，存储完整故事内容）、created_at（时间戳，故事保存时间）。保存成功后返回操作结果（例如保存的故事ID或成功消息）。
获取故事列表接口 (GET /api/get-stories)：用于获取所有已保存的故事条目列表。后端从 Supabase 数据库的stories表读取所有记录，提取每条故事的id、title和created_at字段，生成一个列表返回。响应为JSON格式，包含故事简要信息的数组（每项包括故事ID、标题以及保存时间），方便前端展示“我的故事”列表。
获取故事详情接口 (GET /api/get-story/:id)：用于获取单个故事的完整内容。后端根据URL路径中的id参数，从 Supabase 的stories表查询对应的故事记录。找到后返回该故事的详细信息，包含title、content和created_at字段（均为JSON格式）。如果提供的id不存在，返回相应的错误信息或404状态码。
语音生成接口占位 (GET /api/tts)：预留用于文本转语音（TTS）的接口。目前此接口仅返回“501 Not Implemented”的状态，表示功能尚未实现。未来可以在此接口集成第三方语音合成服务（例如 Google TTS、Baidu TTS 或 ElevenLabs 等），根据请求提供的文本生成语音。当前暂时返回501状态码以占位。
安全性与访问控制
开放访问：鉴于应用定位于儿童使用，当前版本后端接口不设置用户认证或鉴权。所有上述 API 均可被前端直接调用，无需登录凭证，每个用户的数据统一保存在公共数据库中（无多用户隔离）。在后续版本中，可根据需要为“我的故事”等功能添加用户ID关联和登录鉴权，以确保每个用户只能访问自己的数据。
API 密钥管理：将 DeepSeek 的 API Key 配置为 Supabase 后端的秘密（Secret），不要将密钥明文硬编码在代码中。调用 DeepSeek 接口时，从安全存储的配置中读取 API Key，并在请求头中以Authorization: Bearer <API Key>形式传递，保证密钥安全。
技术栈与实现细节
后端框架：使用 Node.js 搭配 Express.js 搭建 RESTful API 服务（Figma Make 默认后端环境基于 Node/Express）。每个接口对应一个 Express 路由，根据 HTTP 方法和路径进行处理。
数据库集成：已通过 Supabase 提供云端 Postgres 数据库并集成到 Figma Make 后端。利用 Supabase 提供的 JavaScript SDK（如@supabase/supabase-js）在后端与数据库交互，例如插入保存故事、查询列表和详情等操作。确保在 Figma Make 中已连接 Supabase 项目并正确配置数据库表stories。
外部API调用：通过fetch或axios等库在后端请求 DeepSeek 官方 API。构造请求时设置正确的URL（例如 DeepSeek 的/chat/completions端点）、请求头（包括内容类型和授权头）和请求体（包含模型参数model: "deepseek-chat"、对话消息messages以及stream: false等配置）。接收到 DeepSeek 返回的故事和分支文本后，解析结果并发送给前端。注意处理可能的网络错误或超时，并返回相应错误状态码。
部署考虑：后端代码应适配 Figma Make/Supabase 无服务器环境，确保每个 API 路由导出为处理函数，方便部署到平台（如 Vercel、Netlify 或 Figma Make 自身的托管环境）。使用异步函数处理数据库和外部API调用，保证不会阻塞主线程，并在需要时适当设置超时时间。
接口文档与代码注释
接口文档：清晰编写每个接口的用途、请求参数和返回格式说明。在生成的代码中，使用简体中文撰写注释，对主要逻辑和步骤进行解释，方便阅读和维护。例如，在/api/generate-story路由处理函数内加注释说明“// 调用 DeepSeek API 生成故事开头和分支”。
代码注释：为关键代码段和函数添加中文注释，例如在数据库操作前后注明“// 将故事保存到 Supabase 数据库”，“// 从数据库读取故事列表”等。注释需言简意赅，准确描述代码意图。所有用户可见的提示、日志或错误消息也尽量使用中文，符合应用面向中文用户的场景。
以上提示词将指导 Figma Make 后端生成器一键创建所需的 API 路由、数据库结构及集成逻辑，实现儿童睡前互动故事App的完整后端功能。

源
您说：
儿童睡前故事App原型r.zip
压缩归档
这是figma设计的，你来评审直接给改进意见作为prompt
ChatGPT 说：
为了更好地评审你上传的 Figma 设计文件并提供改进建议作为 Figmamake 提示词，我想确认几点：

你希望我主要评审的是哪个方面？（比如：界面布局、视觉风格、功能完整性、儿童交互友好性、文案语言等）

是否希望我提供完整的改进建议 prompt，直接让 Figmamake 重绘页面或自动生成组件？

是否存在特定页面或交互流程是你最关心的部分（如首页、故事生成页、我的故事页等）？

确认这些后我会基于你的设计直接给出修改提示词。

您说：
界面布局、视觉风格、功能完整性。2. 对。3 没有
ChatGPT 说：
明白了，我将基于你上传的 Figma 文件，从界面布局、视觉风格和功能完整性三个方面进行评审，并输出一组可直接用于 Figmamake 的改进提示词，帮助你快速优化整体设计。

Research completed in 5m· 1 个源· 12 个搜索
睡前故事App界面设计评审与优化建议

界面布局： 采用简洁直观的单页布局，确保页面结构符合儿童的认知习惯。所有按钮和输入框尺寸足够大，方便 10 岁儿童点击触摸，重要操作放置在易于触及的位置。信息层级清晰明了，没有过多元素让界面显得拥挤，导航流程简单（例如从输入主题到生成故事仅需一两步），避免不必要的跳转或复杂操作路径。
视觉风格： 使用温馨柔和的配色方案，营造睡前宁静氛围（例如柔和的蓝紫色夜空背景搭配星星月亮等插图）。整体风格统一且富有童趣，插图和图标采用卡通插画风格，字体选择清晰易读且略带童趣的字体。注意色彩与插图风格的一致性，让界面元素看起来协调统一，符合 10 岁儿童的审美，并契合睡前故事的场景。
功能完整性： 确保包含儿童睡前故事应用的核心功能流程。界面允许用户输入故事主题，点击按钮后由 AI 自动生成故事；在故事过程中提供交互式选择分支，让儿童参与故事发展；提供“保存故事”功能，将生成的故事收藏保存。设计一个“我的故事”页面或入口，方便查看历史保存的故事，并可点选再次阅读。还应提供播放音频的按钮，一键朗读故事内容。所有交互步骤和功能按钮清晰可见且易于操作，没有缺失关键步骤，也没有多余或无效的界面元素。

源
您说：
逻辑不对，每次 点击按钮应当是选择支线继续往下讲故事，前后剧情要保证连贯，而且要设置互动次数，不能无限，要在5-10次结束故事。而且每次选择至少要给出500字以上的篇幅，不能太短，剧情发展的选择要符合逻辑。
ChatGPT 说：
非常好，感谢你指出关键的互动逻辑。我将更新提示词，让 Figmamake 在故事生成和互动流程上体现出：

每次点击分支选项后，故事继续推进，并保证上下文连贯；

整个故事在 5-10 次互动后自然结束，不能无限推进；

每次生成的新篇幅不少于 500 字，内容丰富饱满；

分支选项要符合前文发展逻辑，不能跳脱或无关联；

在我们继续生成优化后的 Figmamake 提示词前，能否确认以下细节？

你希望 AI 在后端控制分支轮数和文字长度，还是前端每次判断并控制展示？

是否允许用户在故事中途退出/回看上一步？

每次选择分支最多提供几个选项（建议 2-3）？

这些将有助于确保提示词完整并可实现你期望的交互体验。

您说：
你看我的代码，我已经没有在使用figmamake了，在用claude code来开发，并且已经从supabase换到来mongoDB。1. 每轮分支数2个分支，3个轮次。
2. 故事在用户起始输入界面就加上跟更多的提示，以便预期更加可控。
3. 故事生成的逻辑：根据用户首页输入信息来确定故事的要素和情节设计，然后在推理出情节分叉的点，然后针对每个分支来单独设计整体内容并保存，在用户做选择的时候，直接进入分支调去内容。例如，用户输入信息后，按照3轮互动，一共四个段落，第一个段落后提供第一轮的分叉选择2个分支，每个分支再依次进行第二个段落后的分支设计，再到第三轮，以此类推。我不知道说清楚了没有。
4. 先不提供回退选择。
5. 记住是直接生成3轮次2分支的8个完整的分段落的故事，再输出第一个段落并提供分支选择
ChatGPT 说：
非常清晰，你的描述逻辑已经非常完整。我将基于你的新开发环境（Claude Code + MongoDB）生成一组精确的提示词，指导构建符合以下逻辑的故事生成与分支设计系统：

用户输入主题后，立即根据主题生成一个完整的故事结构，包括 3 轮互动（即 3 个选择点），每轮 2 个分支路径（共 8 条完整剧情线）

每段文本长度不少于 500 字

初始段落生成后展示，并引导用户做第一次分支选择，之后顺序进入对应路线（不再实时生成）

我会立刻整理一组用于 Claude Code（或任意代码生成助手）理解并构建这个结构的完整提示说明。

Research completed in 5m· 8 个源· 1 个搜索
多分支儿童故事生成系统设计（MongoDB + Claude Code）

Interactive Bedtime Story Generator - Design & Implementation
1. Input & Prompt Design
To get a rich story idea from the user, the system provides an input interface with guiding questions. Instead of a single text box, the interface asks for details like:
Protagonist – Who is the main character (e.g. a brave little dinosaur, a princess, etc.)?
Setting – Where should the story take place (e.g. a magical forest, outer space)?
Tone/Mood – Does the child want a warm & cozy story, an adventurous tale, or something funny?
These prompts help a 10-year-old articulate a clearer story idea. For example, the theme input might become: “A brave little dinosaur meets aliens in outer space”. This enriched prompt ensures the AI has more context to generate a vivid story.
2. Story Generation Mechanism
Once the user submits the story theme (and optional details above), the backend calls a large language model (e.g. DeepSeek or Claude API) to generate the entire story structure in one go. The story is a choose-your-own-adventure with 3 interactive choice points (branches) and 2 options at each branch, leading to 8 possible endings. The AI returns a structured JSON containing all story segments and branches. The narrative structure is as follows:
Paragraph 1: Common story start for all readers.
Paragraph 2: Two different continuations based on the first choice (branches A1 and A2).
Paragraph 3: Four continuations based on the second choice (branches B1–B4).
Paragraph 4: Eight ending segments based on the third choice (branches C1–C8), each a unique ending.
Each segment is at least 500 characters long, written in child-friendly language. The content is engaging and coherent, and every branch naturally follows from the previous segment’s events. All branches are generated together initially, ensuring the story paths are consistent and well-connected. How the AI is prompted: The backend constructs a prompt for the LLM that includes the user’s theme and guidelines to output a JSON with the full branching story. For example, in pseudocode:
// Pseudo-code: generate full story structure using LLM
async function generateFullStory(theme: string, hero: string, setting: string, tone: string) {
  const userPrompt = `${theme} - Protagonist: ${hero}, Setting: ${setting}, Tone: ${tone}`;
  // Instruction for AI to produce story JSON with required structure
  const instruction = `
    Create an interactive children's bedtime story with 3 choice points (2 options each).
    The story should have a common start and then branch into A1/A2, B1-B4, and C1-C8 endings.
    Each segment >= 500 characters, language simple and fun for a 10-year-old.
    Ensure continuity between segments. 
    Respond in JSON format matching this structure:
    {
      "title": "<Story Title>",
      "segments": {
         "start": "<Paragraph1 text>",
         "A": {
            "A1": {
               "text": "<Paragraph2 text for choice A1>",
               "B1": { "text": "<Paragraph3 text for branch A1-B1>", "C1": "<Ending text A1-B1-C1>", "C2": "<Ending text A1-B1-C2>" },
               "B2": { "text": "<Paragraph3 text for branch A1-B2>", "C3": "<Ending text A1-B2-C3>", "C4": "<Ending text A1-B2-C4>" }
            },
            "A2": {
               "text": "<Paragraph2 text for choice A2>",
               "B3": { "text": "<Paragraph3 text for branch A2-B3>", "C5": "<Ending text A2-B3-C5>", "C6": "<Ending text A2-B3-C6>" },
               "B4": { "text": "<Paragraph3 text for branch A2-B4>", "C7": "<Ending text A2-B4-C7>", "C8": "<Ending text A2-B4-C8>" }
            }
         }
      }
    }`;
  // Call the AI API with the composed prompt (system + user prompt)
  const aiResponse = await callLLM_API(instruction, userPrompt);
  const storyJSON = JSON.parse(aiResponse);
  return storyJSON;
}
// 中文注释：上述函数向大型语言模型发送提示，要求生成包含完整故事结构的JSON。模型返回的JSON包含故事标题以及各段落文本，按照预定的分支结构嵌套。 In this approach, one API call generates the entire story tree. The result is a JSON object containing the story title and all segments (start, A1…C8). Each branching choice is pre-written by the AI. This JSON will be stored in the database so that later we can retrieve segments without further API calls.
3. MongoDB Storage Model
All story data is stored in a MongoDB collection called stories. Each story is one document, structured as follows:
{
  _id: ObjectId,
  title: "Dinosaur and the Aliens",       // short title of the story
  user_prompt: "A dinosaur meets aliens in space...",  // original input or description
  created_at: ISODate("2025-09-10T05:17:00Z"),
  segments: {
    start: "Once upon a time, a brave little dinosaur named Dino was exploring a forest at night when he saw a bright light in the sky...", 
    A: {
      A1: {
        text: "Dino decided to investigate the light. He walked towards it and found a friendly alien spaceship landed in a clearing...",
        B1: { 
          text: "The alien invites Dino to travel to its planet. Dino excitedly climbs aboard the ship...", 
          C1: "On the alien planet, Dino makes new friends and has a wonderful adventure before safely returning home. (Happy ending)", 
          C2: "Dino travels through space but starts feeling homesick, so the alien brings him back and they promise to meet again. (Heartwarming ending)"
        },
        B2: { 
          text: "Dino feels a bit scared and decides to just watch from behind a tree. The alien notices Dino and approaches gently...", 
          C3: "The alien and Dino talk and become friends. Dino learns not to judge by appearances and they say goodbye as friends. (Friendly ending)", 
          C4: "The alien waves goodbye and flies away, leaving Dino to wonder about adventures in the stars. Dino goes home imagining future journeys. (Thoughtful ending)"
        }
      },
      A2: {
        text: "Dino decided it might be safer to hide. He ducked behind some bushes, but curiosity kept him peeking at the spaceship...",
        B3: { 
          text: "The alien steps out with a gift. Dino comes out of hiding, and the alien offers him a glowing star crystal...", 
          C5: "Dino accepts the gift and they play together, lighting up the forest with the crystal. Dino has a magical night and keeps the crystal as a souvenir. (Magical ending)", 
          C6: "Dino politely refuses and watches as the alien plants the crystal in the ground. It grows into a tiny star-tree, lighting the forest every night. (Whimsical ending)"
        },
        B4: { 
          text: "Suddenly, another dinosaur appears, drawn by the light. Dino and the new dinosaur both stare as the alien emerges...", 
          C7: "The two dinosaurs befriend the alien and all three have fun. The next day, Dino and his new dino friend feel brave and happy after the encounter. (Friendship ending)", 
          C8: "The other dinosaur gets scared and runs, and the alien quietly departs. Dino and the other dinosaur later become friends, bonding over the mysterious experience. (Reflective ending)"
        }
      }
    }
  }
}
// 中文注释：上面的JSON结构展示了故事文档在数据库中的存储方式。包含故事标题、用户原始输入以及所有故事段落（start 开头，A1/A2 第一分支，B1-B4 第二层分支，C1-C8 结局段落）。所有文本均已在生成时写好，不需后续实时生成。每个段落还可附加 image 等字段以储存插图信息。 Each story document holds the entire narrative tree. The segments field contains nested sub-documents for each branch and ending. In the example above, the final C1...C8 are stored as strings (each final ending text), while intermediate nodes (A1...B4) have a sub-object with a "text" plus further branches. This consistent structure makes it easy to traverse the story. (Optionally, an "image" field could be added alongside each text to store an illustration URL for that segment.) All content is saved as one JSON object in the database (in a text field). This way, retrieving a story returns everything needed. For instance, the design uses a JSON string field in the DB to store the full story content
GitHub
. This simplifies data retrieval, at the cost of some duplication, but given the relatively small size of each story, it’s manageable.
4. Story Progression Logic
On the frontend, the story progresses in three rounds of choices using the pre-generated content:
Show Opening: When the story starts, display the opening text from segments.start in a card UI. Then present the first set of choices (two buttons labeled e.g. Option A1 and Option A2). These correspond to the branches under segments.A.
First Choice: When the child clicks one of the options (say A1), the next segment text is fetched from segments.A.A1.text and displayed. Now show the second set of choices (branches B1 and B2) available under A1.
Second Choice: The child selects one of these (say B2). Then display segments.A.A1.B2.text. Now present the final set of choices (C3 and C4 in this path).
Third Choice (Ending): The child picks the final branch (say C4). The ending is then displayed from segments.A.A1.B2.C4. This is a final paragraph concluding the story. No more choices are given.
At each choice, the frontend simply looks up the next segment in the nested JSON using the choice key. This can be done by maintaining the current path in the story tree. For example, after choosing A1 then B2, the path is ["A","A1","B2"], so the next choices are the keys of story.segments.A.A1.B2 (which are C3 and C4). The app does not allow going back to previous segments – the story flows forward only, as each decision leads to a new branch. In implementation, you might have a simple function to navigate the JSON structure given a path of choices. For example:
// Navigate the story JSON based on an array of choice keys (like ["A1", "B2"]).
function getSegmentByPath(storyDoc, path: string[]): string {
  let node = storyDoc.segments;
  for (const key of path) {
    if (!node) break;
    // At top level, first key will be "A" (for first choice level)
    // Then "A1" or "A2", etc.
    node = key in node ? node[key] : node;
  }
  // If the node has a 'text' field, return that (intermediate node)
  // If it's a final node (string), return it directly.
  if (typeof node === 'string') return node;
  if (node && node.text) return node.text;
  return "";
}
// 中文注释：getSegmentByPath 函数根据给定路径在 story 文档中查找对应的故事段落文本。如果路径最终指向的是对象节点，返回其 text 字段；如果指向最终字符串结局则直接返回该字符串。 Using this, the frontend logic is straightforward: start with an empty path (show start), then append the chosen branch keys as the user makes choices, and fetch the segment text each time. Since all content is pre-fetched, showing the next part is instant (no API call delays).
5. Text-to-Speech (TTS) Audio Integration
For each story paragraph displayed, the UI can offer a “Play” button 🔊 that reads the text aloud. The backend can integrate a TTS service. For now, we can provide a placeholder API (e.g. GET /api/tts?text=<paragraph_text>) that returns an audio URL or stream. Each segment in the JSON could also include an audioUrl once generated. In our system, after generating the story, we might send each segment’s text to a TTS engine to pre-generate audio files, or generate on-demand. For now, the system just includes the hook for TTS (the button and API endpoint) without full implementation, to be integrated later. This way, when TTS is ready, each paragraph can be played for the child, enhancing the bedtime story experience.
6. UI Design Considerations
The interface is designed to be child-friendly, with a focus on clarity and engagement:
Story Text Display: Each story segment is shown in a large, easy-to-read font on a card-like container. The card has a soft colored background and rounded corners for a friendly look
GitHub
. Illustrations for scenes or characters can be shown alongside the text to keep children interested.
Choice Buttons: After each segment, two big buttons appear for the available choices. These buttons are brightly colored (e.g. one light blue, one light orange) with rounded corners, making them inviting and easy to tap. Each button has a short label (few words) describing the choice, possibly with an icon (e.g. a castle icon if the choice involves a castle) to aid understanding. Only the current step’s choices are shown at any time to avoid overwhelming the child.
Interactive Feedback: When a choice button is clicked, provide immediate visual feedback (like a slight bounce or highlight effect) and maybe a gentle sound (“ding”) to confirm the selection. This positive feedback keeps kids engaged. Then the next story segment card appears with a smooth transition (e.g. fade or slide in), maintaining a magical storybook feel.
Progress & Navigation: There’s no need for a back button during story playback to keep the experience linear and focused. However, an “exit story” home icon (🏠) can be placed in a corner in case the user wants to stop and return to the main page. At the end of the story, show a friendly “The End” illustration and offer a “Save Story” button so the child (or parent) can save it to their library.
Illustrations: Optionally, each segment’s JSON could include an image field. The UI can display these images (e.g. a picture of the brave little dinosaur or the alien spaceship) above or behind the text. This makes the story more visually appealing. If no custom image is provided, a default themed image or none is fine – the text itself is descriptive enough.
7. Example Usage
Finally, here’s how the system works together with a sample scenario:
User Input: The child (with a parent’s help) enters a theme and answers the prompts. For example:
Theme/Title: “恐龙与外星人” (Dinosaur and the Alien)
Protagonist: A little dinosaur named Dino
Setting: In a Jurassic forest at night
Tone: Adventurous and heartwarming
Story Generation Call: The backend receives this input and calls the LLM to generate the story. It might use a call like:
const theme = "恐龙遇到外星人，在侏罗纪森林里展开一次冒险且温馨的邂逅"; 
const fullStory = await generateFullStory(theme, "小恐龙Dino", "侏罗纪森林", "冒险且温馨");
// 'fullStory' is a JSON object with title and segments as shown above.
// Save to MongoDB:
const storyDoc = {
  title: fullStory.title,
  user_prompt: theme,
  created_at: new Date(),
  segments: fullStory.segments
};
storiesCollection.insertOne(storyDoc);  // Save the story document to the database
console.log("Story saved with ID:", storyDoc._id);
// 中文注释：上述代码模拟将用户提供的主题组合成一个带有主角、背景、风格的完整提示，调用generateFullStory生成故事JSON，然后将结果保存到MongoDB的stories集合中。
Frontend Display: Immediately after generation, the app displays the start segment on screen (e.g., “从前有一只勇敢的小恐龙叫Dino…”, etc.). The child sees two buttons for the first choice (say “Go investigate the light” vs “Stay hidden”).
Interaction: The child clicks one, and the next paragraph appears from the pre-stored JSON. This continues for three choices until an ending is shown. At the end, the “Save to My Stories” button is offered.
Saving & Reviewing: If saved, the story’s title and a short preview are stored in the child’s library. Later, they can revisit the story from the My Stories page. The saved story content can be retrieved from the database (using the story’s ID) and replayed without needing regeneration. The system simply reads the JSON from MongoDB and the frontend can render it step by step just like the first time.
This design ensures a smooth, engaging storytelling experience. By generating all content up front and using a structured JSON format, the app guarantees fast responses during interaction (no waiting for AI mid-story) and consistent story paths. The combination of a guided input, an AI-generated branching narrative, and a kid-friendly UI (with potential audio/visual enhancements) makes for a fun and interactive bedtime story system tailored for children.

源


未选择任何文件未选择任何文件
ChatGPT 也可能会犯错。请核查重要信息。

Interactive Bedtime Story Generator - Design & Implementation
1. Input & Prompt Design
To get a rich story idea from the user, the system provides an input interface with guiding questions. Instead of a single text box, the interface asks for details like:
Protagonist – Who is the main character (e.g. a brave little dinosaur, a princess, etc.)?
Setting – Where should the story take place (e.g. a magical forest, outer space)?
Tone/Mood – Does the child want a warm & cozy story, an adventurous tale, or something funny?
These prompts help a 10-year-old articulate a clearer story idea. For example, the theme input might become: “A brave little dinosaur meets aliens in outer space”. This enriched prompt ensures the AI has more context to generate a vivid story.
2. Story Generation Mechanism
Once the user submits the story theme (and optional details above), the backend calls a large language model (e.g. DeepSeek or Claude API) to generate the entire story structure in one go. The story is a choose-your-own-adventure with 3 interactive choice points (branches) and 2 options at each branch, leading to 8 possible endings. The AI returns a structured JSON containing all story segments and branches. The narrative structure is as follows:
Paragraph 1: Common story start for all readers.
Paragraph 2: Two different continuations based on the first choice (branches A1 and A2).
Paragraph 3: Four continuations based on the second choice (branches B1–B4).
Paragraph 4: Eight ending segments based on the third choice (branches C1–C8), each a unique ending.
Each segment is at least 500 characters long, written in child-friendly language. The content is engaging and coherent, and every branch naturally follows from the previous segment’s events. All branches are generated together initially, ensuring the story paths are consistent and well-connected. How the AI is prompted: The backend constructs a prompt for the LLM that includes the user’s theme and guidelines to output a JSON with the full branching story. For example, in pseudocode:
// Pseudo-code: generate full story structure using LLM
async function generateFullStory(theme: string, hero: string, setting: string, tone: string) {
  const userPrompt = `${theme} - Protagonist: ${hero}, Setting: ${setting}, Tone: ${tone}`;
  // Instruction for AI to produce story JSON with required structure
  const instruction = `
    Create an interactive children's bedtime story with 3 choice points (2 options each).
    The story should have a common start and then branch into A1/A2, B1-B4, and C1-C8 endings.
    Each segment >= 500 characters, language simple and fun for a 10-year-old.
    Ensure continuity between segments. 
    Respond in JSON format matching this structure:
    {
      "title": "<Story Title>",
      "segments": {
         "start": "<Paragraph1 text>",
         "A": {
            "A1": {
               "text": "<Paragraph2 text for choice A1>",
               "B1": { "text": "<Paragraph3 text for branch A1-B1>", "C1": "<Ending text A1-B1-C1>", "C2": "<Ending text A1-B1-C2>" },
               "B2": { "text": "<Paragraph3 text for branch A1-B2>", "C3": "<Ending text A1-B2-C3>", "C4": "<Ending text A1-B2-C4>" }
            },
            "A2": {
               "text": "<Paragraph2 text for choice A2>",
               "B3": { "text": "<Paragraph3 text for branch A2-B3>", "C5": "<Ending text A2-B3-C5>", "C6": "<Ending text A2-B3-C6>" },
               "B4": { "text": "<Paragraph3 text for branch A2-B4>", "C7": "<Ending text A2-B4-C7>", "C8": "<Ending text A2-B4-C8>" }
            }
         }
      }
    }`;
  // Call the AI API with the composed prompt (system + user prompt)
  const aiResponse = await callLLM_API(instruction, userPrompt);
  const storyJSON = JSON.parse(aiResponse);
  return storyJSON;
}
// 中文注释：上述函数向大型语言模型发送提示，要求生成包含完整故事结构的JSON。模型返回的JSON包含故事标题以及各段落文本，按照预定的分支结构嵌套。 In this approach, one API call generates the entire story tree. The result is a JSON object containing the story title and all segments (start, A1…C8). Each branching choice is pre-written by the AI. This JSON will be stored in the database so that later we can retrieve segments without further API calls.
3. MongoDB Storage Model
All story data is stored in a MongoDB collection called stories. Each story is one document, structured as follows:
{
  _id: ObjectId,
  title: "Dinosaur and the Aliens",       // short title of the story
  user_prompt: "A dinosaur meets aliens in space...",  // original input or description
  created_at: ISODate("2025-09-10T05:17:00Z"),
  segments: {
    start: "Once upon a time, a brave little dinosaur named Dino was exploring a forest at night when he saw a bright light in the sky...", 
    A: {
      A1: {
        text: "Dino decided to investigate the light. He walked towards it and found a friendly alien spaceship landed in a clearing...",
        B1: { 
          text: "The alien invites Dino to travel to its planet. Dino excitedly climbs aboard the ship...", 
          C1: "On the alien planet, Dino makes new friends and has a wonderful adventure before safely returning home. (Happy ending)", 
          C2: "Dino travels through space but starts feeling homesick, so the alien brings him back and they promise to meet again. (Heartwarming ending)"
        },
        B2: { 
          text: "Dino feels a bit scared and decides to just watch from behind a tree. The alien notices Dino and approaches gently...", 
          C3: "The alien and Dino talk and become friends. Dino learns not to judge by appearances and they say goodbye as friends. (Friendly ending)", 
          C4: "The alien waves goodbye and flies away, leaving Dino to wonder about adventures in the stars. Dino goes home imagining future journeys. (Thoughtful ending)"
        }
      },
      A2: {
        text: "Dino decided it might be safer to hide. He ducked behind some bushes, but curiosity kept him peeking at the spaceship...",
        B3: { 
          text: "The alien steps out with a gift. Dino comes out of hiding, and the alien offers him a glowing star crystal...", 
          C5: "Dino accepts the gift and they play together, lighting up the forest with the crystal. Dino has a magical night and keeps the crystal as a souvenir. (Magical ending)", 
          C6: "Dino politely refuses and watches as the alien plants the crystal in the ground. It grows into a tiny star-tree, lighting the forest every night. (Whimsical ending)"
        },
        B4: { 
          text: "Suddenly, another dinosaur appears, drawn by the light. Dino and the new dinosaur both stare as the alien emerges...", 
          C7: "The two dinosaurs befriend the alien and all three have fun. The next day, Dino and his new dino friend feel brave and happy after the encounter. (Friendship ending)", 
          C8: "The other dinosaur gets scared and runs, and the alien quietly departs. Dino and the other dinosaur later become friends, bonding over the mysterious experience. (Reflective ending)"
        }
      }
    }
  }
}
// 中文注释：上面的JSON结构展示了故事文档在数据库中的存储方式。包含故事标题、用户原始输入以及所有故事段落（start 开头，A1/A2 第一分支，B1-B4 第二层分支，C1-C8 结局段落）。所有文本均已在生成时写好，不需后续实时生成。每个段落还可附加 image 等字段以储存插图信息。 Each story document holds the entire narrative tree. The segments field contains nested sub-documents for each branch and ending. In the example above, the final C1...C8 are stored as strings (each final ending text), while intermediate nodes (A1...B4) have a sub-object with a "text" plus further branches. This consistent structure makes it easy to traverse the story. (Optionally, an "image" field could be added alongside each text to store an illustration URL for that segment.) All content is saved as one JSON object in the database (in a text field). This way, retrieving a story returns everything needed. For instance, the design uses a JSON string field in the DB to store the full story content
GitHub
. This simplifies data retrieval, at the cost of some duplication, but given the relatively small size of each story, it’s manageable.
4. Story Progression Logic
On the frontend, the story progresses in three rounds of choices using the pre-generated content:
Show Opening: When the story starts, display the opening text from segments.start in a card UI. Then present the first set of choices (two buttons labeled e.g. Option A1 and Option A2). These correspond to the branches under segments.A.
First Choice: When the child clicks one of the options (say A1), the next segment text is fetched from segments.A.A1.text and displayed. Now show the second set of choices (branches B1 and B2) available under A1.
Second Choice: The child selects one of these (say B2). Then display segments.A.A1.B2.text. Now present the final set of choices (C3 and C4 in this path).
Third Choice (Ending): The child picks the final branch (say C4). The ending is then displayed from segments.A.A1.B2.C4. This is a final paragraph concluding the story. No more choices are given.
At each choice, the frontend simply looks up the next segment in the nested JSON using the choice key. This can be done by maintaining the current path in the story tree. For example, after choosing A1 then B2, the path is ["A","A1","B2"], so the next choices are the keys of story.segments.A.A1.B2 (which are C3 and C4). The app does not allow going back to previous segments – the story flows forward only, as each decision leads to a new branch. In implementation, you might have a simple function to navigate the JSON structure given a path of choices. For example:
// Navigate the story JSON based on an array of choice keys (like ["A1", "B2"]).
function getSegmentByPath(storyDoc, path: string[]): string {
  let node = storyDoc.segments;
  for (const key of path) {
    if (!node) break;
    // At top level, first key will be "A" (for first choice level)
    // Then "A1" or "A2", etc.
    node = key in node ? node[key] : node;
  }
  // If the node has a 'text' field, return that (intermediate node)
  // If it's a final node (string), return it directly.
  if (typeof node === 'string') return node;
  if (node && node.text) return node.text;
  return "";
}
// 中文注释：getSegmentByPath 函数根据给定路径在 story 文档中查找对应的故事段落文本。如果路径最终指向的是对象节点，返回其 text 字段；如果指向最终字符串结局则直接返回该字符串。 Using this, the frontend logic is straightforward: start with an empty path (show start), then append the chosen branch keys as the user makes choices, and fetch the segment text each time. Since all content is pre-fetched, showing the next part is instant (no API call delays).
5. Text-to-Speech (TTS) Audio Integration
For each story paragraph displayed, the UI can offer a “Play” button 🔊 that reads the text aloud. The backend can integrate a TTS service. For now, we can provide a placeholder API (e.g. GET /api/tts?text=<paragraph_text>) that returns an audio URL or stream. Each segment in the JSON could also include an audioUrl once generated. In our system, after generating the story, we might send each segment’s text to a TTS engine to pre-generate audio files, or generate on-demand. For now, the system just includes the hook for TTS (the button and API endpoint) without full implementation, to be integrated later. This way, when TTS is ready, each paragraph can be played for the child, enhancing the bedtime story experience.
6. UI Design Considerations
The interface is designed to be child-friendly, with a focus on clarity and engagement:
Story Text Display: Each story segment is shown in a large, easy-to-read font on a card-like container. The card has a soft colored background and rounded corners for a friendly look
GitHub
. Illustrations for scenes or characters can be shown alongside the text to keep children interested.
Choice Buttons: After each segment, two big buttons appear for the available choices. These buttons are brightly colored (e.g. one light blue, one light orange) with rounded corners, making them inviting and easy to tap. Each button has a short label (few words) describing the choice, possibly with an icon (e.g. a castle icon if the choice involves a castle) to aid understanding. Only the current step’s choices are shown at any time to avoid overwhelming the child.
Interactive Feedback: When a choice button is clicked, provide immediate visual feedback (like a slight bounce or highlight effect) and maybe a gentle sound (“ding”) to confirm the selection. This positive feedback keeps kids engaged. Then the next story segment card appears with a smooth transition (e.g. fade or slide in), maintaining a magical storybook feel.
Progress & Navigation: There’s no need for a back button during story playback to keep the experience linear and focused. However, an “exit story” home icon (🏠) can be placed in a corner in case the user wants to stop and return to the main page. At the end of the story, show a friendly “The End” illustration and offer a “Save Story” button so the child (or parent) can save it to their library.
Illustrations: Optionally, each segment’s JSON could include an image field. The UI can display these images (e.g. a picture of the brave little dinosaur or the alien spaceship) above or behind the text. This makes the story more visually appealing. If no custom image is provided, a default themed image or none is fine – the text itself is descriptive enough.
7. Example Usage
Finally, here’s how the system works together with a sample scenario:
User Input: The child (with a parent’s help) enters a theme and answers the prompts. For example:
Theme/Title: “恐龙与外星人” (Dinosaur and the Alien)
Protagonist: A little dinosaur named Dino
Setting: In a Jurassic forest at night
Tone: Adventurous and heartwarming
Story Generation Call: The backend receives this input and calls the LLM to generate the story. It might use a call like:
const theme = "恐龙遇到外星人，在侏罗纪森林里展开一次冒险且温馨的邂逅"; 
const fullStory = await generateFullStory(theme, "小恐龙Dino", "侏罗纪森林", "冒险且温馨");
// 'fullStory' is a JSON object with title and segments as shown above.
// Save to MongoDB:
const storyDoc = {
  title: fullStory.title,
  user_prompt: theme,
  created_at: new Date(),
  segments: fullStory.segments
};
storiesCollection.insertOne(storyDoc);  // Save the story document to the database
console.log("Story saved with ID:", storyDoc._id);
// 中文注释：上述代码模拟将用户提供的主题组合成一个带有主角、背景、风格的完整提示，调用generateFullStory生成故事JSON，然后将结果保存到MongoDB的stories集合中。
Frontend Display: Immediately after generation, the app displays the start segment on screen (e.g., “从前有一只勇敢的小恐龙叫Dino…”, etc.). The child sees two buttons for the first choice (say “Go investigate the light” vs “Stay hidden”).
Interaction: The child clicks one, and the next paragraph appears from the pre-stored JSON. This continues for three choices until an ending is shown. At the end, the “Save to My Stories” button is offered.
Saving & Reviewing: If saved, the story’s title and a short preview are stored in the child’s library. Later, they can revisit the story from the My Stories page. The saved story content can be retrieved from the database (using the story’s ID) and replayed without needing regeneration. The system simply reads the JSON from MongoDB and the frontend can render it step by step just like the first time.
This design ensures a smooth, engaging storytelling experience. By generating all content up front and using a structured JSON format, the app guarantees fast responses during interaction (no waiting for AI mid-story) and consistent story paths. The combination of a guided input, an AI-generated branching narrative, and a kid-friendly UI (with potential audio/visual enhancements) makes for a fun and interactive bedtime story system tailored for children.
引用
GitHub
CLAUDE.md

https://github.com/haizhouyuan/storyapp/blob/2c97b5cf060123c475638622a32fa36d89c2cac6/CLAUDE.md#L126-L131
GitHub
input.md

https://github.com/haizhouyuan/storyapp/blob/2c97b5cf060123c475638622a32fa36d89c2cac6/input.md#L2-L5
全部来源

github